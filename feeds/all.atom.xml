<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mestrace的个人博客</title><link href="https://mestrace.github.io/" rel="alternate"></link><link href="https://mestrace.github.io/feeds/all.atom.xml" rel="self"></link><id>https://mestrace.github.io/</id><updated>2023-03-14T00:00:00+08:00</updated><subtitle>Software Developer</subtitle><entry><title>【Leetcode题解】2580. Count Ways to Group Overlapping Ranges</title><link href="https://mestrace.github.io/posts/2023/Mar/14/2580-count-ways-to-group-overlapping-ranges/" rel="alternate"></link><published>2023-03-14T00:00:00+08:00</published><updated>2023-03-14T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-03-14:/posts/2023/Mar/14/2580-count-ways-to-group-overlapping-ranges/</id><summary type="html">&lt;p&gt;2023-03 - Biweekly Contest 99 - Leetcode 2580 Count Ways to Group Overlapping Ranges - 计算重叠范围的分组方式 - 我的解法，思路和方法&lt;/p&gt;</summary><content type="html">&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个列表的&lt;code&gt;ranges&lt;/code&gt;，其中&lt;code&gt;range[i] = [start, end]&lt;/code&gt;包含了一个区间的开始和结束。我们想要把这个区间分为两个部分，且两个部分里面的每一对&lt;code&gt;range[i]&lt;/code&gt;和&lt;code&gt;range[j]&lt;/code&gt;没有相交的部分。&lt;/p&gt;
&lt;p&gt;题目要求我们找到有多少种分为两个部分的方法，且因为数量非常大，需要模&lt;code&gt;1e9 + 7&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;这道题是2023.03.04的&lt;a href="https://leetcode.com/contest/biweekly-contest-99/"&gt;双周赛 Biweekly Contest 99&lt;/a&gt;第三题（&lt;a href="https://leetcode.com/contest/biweekly-contest-99/problems/count-ways-to-group-overlapping-ranges/"&gt;原题链接&lt;/a&gt;）。这一题的大致思路是这样：找到并合并相交的区间，最终知道不相交的区间后，计算有多少种分组方式。&lt;/p&gt;
&lt;p&gt;找到相交区间的题目已经很多了，包括这种经典的区间相交，还有经典的会议室系列。这类型题目的一个共性就是需要先对入参的时间进行排序。原理也比较好理解，如果你想要知道某个区间是否相交，最好的方式就是查看他临近的事件，而较远的事件就无需关注。对于这道题来说，我们只是要尽可能的合并相交的区间，没有什么太复杂的性质。所以我们先根据开始时间升序排序即可。排序之后，我们就可以遍历整个区间一个一个看是否相交并进行合并。&lt;/p&gt;
&lt;p&gt;假设我们已经有了一个列表的不相交的区间，我们怎么算有多少种分组方式呢。在这个时候我选择的是画一些例子来找规律。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Input: [1,2]
Output: 2
Explanation:
[1,2] &amp;amp; empty
empty &amp;amp; [1,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Input: [[1,2], [3,4]]
Outpu: 4
Explanation:
[1,2] [3,4] &amp;amp; empty
[1,2] &amp;amp; [3,4]
[3,4] &amp;amp; [1,2]
empty &amp;amp; [1,2] [3,4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Input: [[1,2],[3,4],[5,6]]
Output: 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这里的时候似乎我们看到了这么一个规律，我们知道有&lt;code&gt;n&lt;/code&gt;组的数量之后，结果永远都是&lt;code&gt;2^n&lt;/code&gt;。此外，我们还可以确定的事，我们只需要知道不相交区间的个数就可以知道，而不需要具体的知道怎么相交。我们用数学方式去验证一下。首先我们只需要管左边有什么元素，因为右边有什么元素可根据左边来确定。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Left elements
0: empty set = 1
1: n choose 1 = n
2: n choose 2
3: n choose 3
until
n : n choose n = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而我们可以观察到，这个正好和数学上的二项式展开的形式非常相似。我们再来看看杨辉三角（或者帕斯卡三角，Pascal's Triangle）。我们会发现其实这个问题的解就是每一横行求和！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;                                  &lt;span class="mi"&gt;1&lt;/span&gt;                               
&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;                              &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;                           
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;                          &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="mi"&gt;2&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;                       
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;                      &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="mi"&gt;3&lt;/span&gt;       &lt;span class="mi"&gt;3&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;                   
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;                  &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="mi"&gt;4&lt;/span&gt;       &lt;span class="mi"&gt;6&lt;/span&gt;       &lt;span class="mi"&gt;4&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;               
&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;              &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="mi"&gt;5&lt;/span&gt;       &lt;span class="mi"&gt;10&lt;/span&gt;      &lt;span class="mi"&gt;10&lt;/span&gt;      &lt;span class="mi"&gt;5&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;           
&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;          &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="mi"&gt;6&lt;/span&gt;       &lt;span class="mi"&gt;15&lt;/span&gt;      &lt;span class="mi"&gt;20&lt;/span&gt;      &lt;span class="mi"&gt;15&lt;/span&gt;      &lt;span class="mi"&gt;6&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;       
&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="mi"&gt;7&lt;/span&gt;       &lt;span class="mi"&gt;21&lt;/span&gt;      &lt;span class="mi"&gt;35&lt;/span&gt;      &lt;span class="mi"&gt;35&lt;/span&gt;      &lt;span class="mi"&gt;21&lt;/span&gt;      &lt;span class="mi"&gt;7&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;   
&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="mi"&gt;8&lt;/span&gt;       &lt;span class="mi"&gt;28&lt;/span&gt;      &lt;span class="mi"&gt;56&lt;/span&gt;      &lt;span class="mi"&gt;70&lt;/span&gt;      &lt;span class="mi"&gt;56&lt;/span&gt;      &lt;span class="mi"&gt;28&lt;/span&gt;      &lt;span class="mi"&gt;8&lt;/span&gt;       &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总而言之，非常巧妙的我们可以通过观察的方式得出二次幂就是这个题目的答案的这个结论。具体的证明和推倒就留给读者了。&lt;/p&gt;
&lt;h2&gt;解法&lt;/h2&gt;
&lt;p&gt;不多废话，直接上解法。这道题基本上就跟我们讲的一样，先进行排序，求出相交个数&lt;code&gt;groups&lt;/code&gt;之后，直接用二次幂公式进行计算。&lt;/p&gt;
&lt;p&gt;这里用二次幂公式的一个小机器。之前的周赛中是二次幂取模之后减去一个数求结果&lt;sup id="sf-2580-count-ways-to-group-overlapping-ranges-1-back"&gt;&lt;a href="#sf-2580-count-ways-to-group-overlapping-ranges-1" class="simple-footnote" title="2550. Count Collisions of Monkeys on a Polygon"&gt;1&lt;/a&gt;&lt;/sup&gt;，但是直接&lt;code&gt;pow&lt;/code&gt;取模会直接导致算出负数的结果，因此这样算可以避免&lt;code&gt;((2^(n-1) % MOD) * 2 - m) % MOD&lt;/code&gt; 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;MOD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1e9&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;countWays&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ranges&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;isOverlap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;overlap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])]&lt;/span&gt;

        &lt;span class="n"&gt;ranges&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranges&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# print(ranges)&lt;/span&gt;

        &lt;span class="n"&gt;curr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ranges&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;groups&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranges&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;isOverlap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ranges&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]):&lt;/span&gt;
                &lt;span class="n"&gt;curr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;overlap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ranges&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                &lt;span class="k"&gt;continue&lt;/span&gt;
            &lt;span class="n"&gt;groups&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="n"&gt;curr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ranges&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="c1"&gt;# last group&lt;/span&gt;
        &lt;span class="n"&gt;groups&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

        &lt;span class="c1"&gt;# print("groups", groups)&lt;/span&gt;


        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;groups&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;MOD&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;MOD&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而对于是用别的语言的同学来说，则需要自己手动实现带取模的二次幂方法，简单来说就是递归求&lt;code&gt;2^(n - 1)&lt;/code&gt;，在半途中就需要取模。这里简单贴一个我写的版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;MOD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1e9&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;MOD&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;MOD&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这道题思路比较简单，但是难点在于把二项式分解和取模的部分跟这道题结合起来。大家一起努力吧。&lt;/p&gt;
&lt;p&gt;如果你想变得更强的话，可以做做&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/meeting-rooms/"&gt;Easy - 252. Meeting Rooms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/non-overlapping-intervals/"&gt;Medium - 435. Non-overlapping Intervals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/"&gt;Medium - 1621. Number of Sets of K Non-Overlapping Line Segments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/meeting-scheduler/"&gt;Medium - 1229. Meeting Scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/meeting-rooms-iii/"&gt;Hard - 2402. Meeting Rooms III&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还可以延伸看看&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://math.stackexchange.com/questions/519832/proving-by-induction-that-sum-k-0nn-choose-k-2n"&gt;Proof By Induction of the Summation of n choose k&lt;/a&gt; 这个summation的数学证明。&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Binomial_coefficient"&gt;Wikipedia - Binomial Coefficient&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;&lt;ol class="simple-footnotes"&gt;&lt;li id="sf-2580-count-ways-to-group-overlapping-ranges-1"&gt;&lt;a href="https://leetcode.com/problems/count-collisions-of-monkeys-on-a-polygon/description/"&gt;2550. Count Collisions of Monkeys on a Polygon&lt;/a&gt; &lt;a href="#sf-2580-count-ways-to-group-overlapping-ranges-1-back" class="simple-footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</content><category term="Leetcode"></category><category term="Contest"></category><category term="Math"></category></entry><entry><title>【Leetcode题解】2588. Count the Number of Beautiful Subarrays</title><link href="https://mestrace.github.io/posts/2023/Mar/12/2588-count-the-number-of-beautiful-subarrays/" rel="alternate"></link><published>2023-03-12T00:00:00+08:00</published><updated>2023-03-12T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-03-12:/posts/2023/Mar/12/2588-count-the-number-of-beautiful-subarrays/</id><summary type="html">&lt;p&gt;2023-03 Weekly Contest 336 Leetcode 2588 Count the Number of Beautiful Subarrays 我的解题思路&lt;/p&gt;</summary><content type="html">&lt;p&gt;每周都被周赛折磨，真是痛苦。早上刚打完周赛，趁着记忆还热乎，赶紧来写一下这题的题解。&lt;/p&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个列表的数字&lt;code&gt;nums&lt;/code&gt;, 要求求出指定符合条件的子数组数量。子数组&lt;code&gt;nums[i:j]&lt;/code&gt;要满足一定条件才可以。首先我们定义一个动作，消去子数组里任意两个数的第&lt;code&gt;k&lt;/code&gt;个bit（当然这两个数的&lt;code&gt;k bit&lt;/code&gt;都要为&lt;code&gt;1&lt;/code&gt;）。将以上动作执行无限次数之后可以子数组全部是&lt;code&gt;0&lt;/code&gt;，那么我们就说子数组&lt;code&gt;nums[i:j]&lt;/code&gt;为满足条件的子数组。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;这道题是2023.03.12的&lt;a href="https://leetcode.com/contest/weekly-contest-336/"&gt;周赛Weekly Contest 336&lt;/a&gt;第三题（&lt;a href="https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/"&gt;原题链接&lt;/a&gt;）。我一开始想的是否可以用双指针做，但是仔细想想这道题不大对劲。我们用双指针是因为找双指针指向的区域其实是一个子问题，解决了这个子问题就可以通过很简单的方式方式判断下一个问题&lt;code&gt;[left, right + 1]&lt;/code&gt;是否符合&lt;sup id="sf-2588-count-the-number-of-beautiful-subarrays-1-back"&gt;&lt;a href="#sf-2588-count-the-number-of-beautiful-subarrays-1" class="simple-footnote" title="双指针解法的子数组题，可以移步【Leetcode题解】2444. Count Subarrays With Fixed Bound "&gt;1&lt;/a&gt;&lt;/sup&gt;。但这一题并不能用这个方法解。我们先来看个例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Input: [4,3,1,2,4]
Output: 2
Explanation
[3] not ok
[3,1] not ok
[3,1,2] ok
[3,1,2,4] not ok
[4,3,1,2,4] ok
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面这个例子中我们可以看到，&lt;code&gt;[3,1,2]&lt;/code&gt;和&lt;code&gt;[3,1,2,4]&lt;/code&gt;并没有直接联系，因此我们不太好用双指针来解决这个问题。&lt;/p&gt;
&lt;p&gt;那么能不能从问题本身的性质解决呢？先转换一下问题，如果我们要按照题目条件将一个子数组都变为0，意味着这个子数组的bit count每一个都要是偶数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[3,1,2]
3 = 0b11
2 = 0b10
1 = 0b01
=&amp;gt; {0: 2, 1: 2}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[4,3,1,2,4]
4 = 0b100 
4 = 0b100
=&amp;gt; {0: 2, 1: 2, 2: 2}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么，如果我们想要知道一个子数组是否满足条件，我们只需要检查他们每一比特的数量是否都为偶数；如果是的话，就可以消除了；否则的话，这个子数组就不满足条件。再往前推一步，我们并不需要知道他的count，只需要知道是否存在奇数个；如果是偶数个那就直接消掉归0就好了。&lt;em&gt;看到这里，是否觉得有点眼熟？&lt;/em&gt;&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/cong-tian-er-jiang.jpg"&gt;
&lt;/p&gt;

&lt;p&gt;对了，就是位运算里面的XOR异或操作。先简单回顾一下XOR。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Input  Output
A  B  A XOR B
0  0     0
0  1     1
1  0     1
1  1     0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;基于异或操作的真值表，前人总结出来了几个性质&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;交换律（commutative）（这个不用我多解释吧）&lt;/li&gt;
&lt;li&gt;结合律（associative）：即&lt;code&gt;(A XOR B) XOR C == A XOR (B XOR C)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;单位元（Identity element）: 对于任何数X，都有&lt;code&gt;X XOR X = 0&lt;/code&gt;，&lt;code&gt;X XOR 0 = x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自反性（self-inverse）：&lt;code&gt;A XOR B XOR B = A xor 0 = A&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;做过&lt;a href="https://leetcode.com/problems/find-the-duplicate-number/"&gt;287. Find the Duplicate Number&lt;/a&gt;的朋友肯定不会对这陌生。这道题目里面，我们把重复的数据都XOR一遍，剩下的那个数字就是我们要找的答案。&lt;/p&gt;
&lt;p&gt;回到我们的2588。结合了位运算，我们可以知道：如果&lt;code&gt;XOR(nums[i:j]) == 0&lt;/code&gt;，那么我们就说他是一个符合条件的子数组。想要得到这个结果的话，我们可以每次都循环XOR每一个数；或者，如果我们更聪明一点，根据上面的性质，我们有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  XOR(nums[i:j])
= XOR(nums[i:j]) XOR (XOR(nums[0:i]) XOR XOR(nums[0:i])) (identity element)
= XOR(nums[0:i]) XOR XOR(nums[0:j]) (associative)

which implies XOR(nums[0:i]) == XOR(nums[0:j]) (identity element)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据这以上的性质，我们可以转换为&lt;code&gt;XOR(nums[0:i]) == XOR(nums[0:j])&lt;/code&gt;。&lt;em&gt;看到这里，是否觉得有点眼熟？&lt;/em&gt;&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/cong-tian-er-jiang.jpg"&gt;
&lt;/p&gt;

&lt;p&gt;对了，就是可恶的prefix sum……哦不对，应该是prefix xor。所以啊，不要小瞧基础题目啊。&lt;/p&gt;
&lt;p&gt;那么现在我们有一个异或&lt;code&gt;prefix&lt;/code&gt;了。给定一个位置&lt;code&gt;j&lt;/code&gt;，我们怎么找出&lt;code&gt;i &amp;lt; j&lt;/code&gt;且&lt;code&gt;prefix[i] == prefix[j]&lt;/code&gt;（我们要找的子数组）呢？ 把&lt;code&gt;[0:j)&lt;/code&gt;扫过去的话是&lt;code&gt;O(n^2)&lt;/code&gt;的复杂度，未免有点naive。如果我们能够把&lt;code&gt;j&lt;/code&gt;之前所有的值的数都记一下……等一下，&lt;em&gt;看到这里，是否觉得有点眼熟？&lt;/em&gt;&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/cong-tian-er-jiang.jpg"&gt;
&lt;/p&gt;

&lt;p&gt;这！@#¥不就是&lt;a href="https://leetcode.com/problems/two-sum/"&gt;1. Two Sum&lt;/a&gt;吗？用一个hashmap把之前出现的次数都记一下。假设前面有&lt;code&gt;k&lt;/code&gt;个&lt;code&gt;i&lt;/code&gt;的候选，其中每一个&lt;code&gt;i&lt;/code&gt;都可以和我们当前的&lt;code&gt;j&lt;/code&gt;组成一个符合条件的子数组结果，那么我们就把结果加上&lt;code&gt;k&lt;/code&gt;，问题解决！&lt;/p&gt;
&lt;h2&gt;解法&lt;/h2&gt;
&lt;p&gt;这里要注意的是，一开始初始化prefix的时候我放了一个0，因为如果是&lt;code&gt;[0,i)&lt;/code&gt;是空集的话，任意的&lt;code&gt;j&lt;/code&gt;也可以组成一个符合条件的子数组&lt;code&gt;[0,j]&lt;/code&gt;。其他的就跟我们上面说的差不多，直接梭就行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;beautifulSubarrays&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;prefix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# print(prefix)&lt;/span&gt;

        &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;今天周赛的这一题可谓是结合了几个关键的基础知识所研发出来的新题，我称之为眼熟题。遇到这种眼熟题也没有办法，打铁还需自身硬，各位继续加油。&lt;/p&gt;
&lt;p&gt;这次周赛的其他题目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/count-the-number-of-vowel-strings-in-range/"&gt;Easy - 2586. Count the Number of Vowel Strings in Range&lt;/a&gt; （手速题）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/rearrange-array-to-maximize-prefix-score/"&gt;Medium - 2587. Rearrange Array to Maximize Prefix Score&lt;/a&gt; （手速题）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/minimum-time-to-complete-all-tasks/"&gt;Hard - 2589. Minimum Time to Complete All Tasks&lt;/a&gt; （&lt;a href="https://mestrace.github.io/posts/2023/Mar/12/2589-minimum-time-to-complete-all-tasks/"&gt;我的题解&lt;/a&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你想变得更强的话，可以做做&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/xor-operation-in-an-array/"&gt;1486. XOR Operation in an Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/find-xor-beauty-of-array/"&gt;2527. Find Xor-Beauty of Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/bitwise-xor-of-all-pairings/"&gt;2425. Bitwise XOR of All Pairings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/maximum-xor-with-an-element-from-array/"&gt;1707. Maximum XOR With an Element From Array&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;&lt;ol class="simple-footnotes"&gt;&lt;li id="sf-2588-count-the-number-of-beautiful-subarrays-1"&gt;双指针解法的子数组题，可以移步&lt;a href="https://mestrace.github.io/posts/2023/Mar/04/2444-count-subarrays-with-fixed-bounds/"&gt;【Leetcode题解】2444. Count Subarrays With Fixed Bound&lt;/a&gt;  &lt;a href="#sf-2588-count-the-number-of-beautiful-subarrays-1-back" class="simple-footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</content><category term="Leetcode"></category><category term="Contest"></category><category term="Subarray"></category></entry><entry><title>【Leetcode题解】2589. Minimum Time to Complete All Tasks</title><link href="https://mestrace.github.io/posts/2023/Mar/12/2589-minimum-time-to-complete-all-tasks/" rel="alternate"></link><published>2023-03-12T00:00:00+08:00</published><updated>2023-03-12T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-03-12:/posts/2023/Mar/12/2589-minimum-time-to-complete-all-tasks/</id><summary type="html">&lt;p&gt;2023-03 Weekly Contest 336 Leetcode 2589 Minimum Time to Complete All Tasks My Solution 我的解题思路&lt;/p&gt;</summary><content type="html">&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;给定一个列表的&lt;code&gt;tasks&lt;/code&gt;，其中每个&lt;code&gt;task[i] = [start, end, duration]&lt;/code&gt;需要在&lt;code&gt;[start, end]&lt;/code&gt;中任意时间运行完成，并且最终需要运行&lt;code&gt;duration&lt;/code&gt;秒。&lt;/p&gt;
&lt;p&gt;此外，我们的机器可以并行运行任意数量的&lt;code&gt;task[i]&lt;/code&gt;，可以随时开始或者停止，不运行的时候就需要关闭。我们需要找到这台机器能并行完成这些任务的最短时间。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;这道题是2023.03.12的&lt;a href="https://leetcode.com/contest/weekly-contest-336/"&gt;周赛Weekly Contest 336&lt;/a&gt;第四题（&lt;a href="https://leetcode.com/problems/minimum-time-to-complete-all-tasks/description/"&gt;原题链接&lt;/a&gt;）。挺可惜的，我因为看错题目了，没做出来。我一开始以为是需要在连续区间运行的，直接开了个2000个元素的开始梭backtracking with memorization。各位看题一定要仔细看……&lt;/p&gt;
&lt;p&gt;不扯犊子了，直接进入主题。对于这种涉及到调度的问题，一个经验法则就是先看看能不能用排序和贪心做。对于这种类型的题目，搜索空间通常非常的大。比如给定一个任务&lt;code&gt;task[i] = [1,2000,1]&lt;/code&gt;直接干到&lt;code&gt;O(n^2)&lt;/code&gt;，所以不是非常可取。那么既然决定了用贪心，我们就要考虑怎么贪才能满足我们的最小条件。对于这道题，我们期望是在区间内，任务能够尽可能的跟其他任务并行，因为题目并没有限制机器并行的任务个数。此外，假如我们拿到了一个任务，但是他前面没有其他任务可以并行，我们需要尽可能晚地运行这个任务，才能让后面的任务跟他一起并行。此外，排序怎么拍也决定了我们执行贪心的顺序，也正是这道题目的难点。我先放在前面，这道题我们应该根据结束时间升序。一个比较直白的解释是，结束时间较早的任务需要先运行才可以确定后面的任务要怎么并行。我们来看一个例子，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;Input&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;[[&lt;span class="mi"&gt;8&lt;/span&gt;,&lt;span class="mi"&gt;19&lt;/span&gt;,&lt;span class="mi"&gt;1&lt;/span&gt;],[&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="mi"&gt;20&lt;/span&gt;,&lt;span class="mi"&gt;1&lt;/span&gt;],[&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="mi"&gt;20&lt;/span&gt;,&lt;span class="mi"&gt;2&lt;/span&gt;],[&lt;span class="mi"&gt;6&lt;/span&gt;,&lt;span class="mi"&gt;13&lt;/span&gt;,&lt;span class="mi"&gt;3&lt;/span&gt;]]
&lt;span class="nv"&gt;Sort&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;based&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;on&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;[[&lt;span class="mi"&gt;6&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;],&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="mi"&gt;8&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;],&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;],&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;]]
&lt;span class="nv"&gt;Sort&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;based&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;on&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;[[&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;],&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;],&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="mi"&gt;6&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;],&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="mi"&gt;8&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们以任务 [1,20,2] 和 [6,13,3] 为例，当我们执行一个任务时，我们并不知道后续任务的处理方式，因此可能得到非最优解。但是，如果我们按照结束时间的先后顺序来执行任务，那么当我们处理一个任务时，我们已经知道在它之后不会再有比它更早结束的任务，因此我们可以放心地使用贪心算法进行处理。&lt;/p&gt;
&lt;h2&gt;题解&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;findMinimumTime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kc"&gt;False&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2001&lt;/span&gt;

        &lt;span class="n"&gt;tasks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;duration&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;tasks&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;duration&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;duration&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;continue&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="c1"&gt;# print(i, duration, line[i])&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;duration&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
                    &lt;span class="k"&gt;continue&lt;/span&gt;
                &lt;span class="n"&gt;duration&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;


        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这道题个人感觉并不是特别难，但最重要的应该是在周赛的那种压力下能不能想到这个思路。各位继续加油吧。&lt;/p&gt;
&lt;p&gt;这次周赛的其他题目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/count-the-number-of-vowel-strings-in-range/"&gt;Easy - 2586. Count the Number of Vowel Strings in Range&lt;/a&gt; （手速题）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/rearrange-array-to-maximize-prefix-score/"&gt;Medium - 2587. Rearrange Array to Maximize Prefix Score&lt;/a&gt; （手速题）&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/"&gt;Medium - 2588. Count the Number of Beautiful Subarrays&lt;/a&gt; （&lt;a href="https://mestrace.github.io/posts/2023/Mar/12/2588-count-the-number-of-beautiful-subarrays/"&gt;我的题解&lt;/a&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你想变得更强的话，可以做做&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/single-threaded-cpu/"&gt;1834. Single-Threaded CPU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/task-scheduler-ii"&gt;2365. Task Scheduler II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/course-schedule-iv/"&gt;1462. Course Schedule IV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://leetcode.com/problems/meeting-scheduler/"&gt;1229. Meeting Scheduler&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="Leetcode"></category><category term="Contest"></category><category term="Scheduling"></category></entry><entry><title>我是如何做SEO优化的</title><link href="https://mestrace.github.io/posts/2023/Mar/11/myblog-seo/" rel="alternate"></link><published>2023-03-11T00:00:00+08:00</published><updated>2023-03-11T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-03-11:/posts/2023/Mar/11/myblog-seo/</id><summary type="html">&lt;p&gt;一开始，我的写博客是出于对自己成长的记录，但时间推移后，我希望更多人能够阅读我的文章。虽然与同事和朋友分享文 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;一开始，我的写博客是出于对自己成长的记录，但时间推移后，我希望更多人能够阅读我的文章。虽然与同事和朋友分享文章可以带来满足感，但如果能吸引更多读者并获得他们的认可和反馈，那将会极大地推动我的进步并让我更加热爱写作。因此，让陌生人发现我的博客已成为我的首要问题。&lt;/p&gt;
&lt;p&gt;众所周知，搜索引擎使用网络爬虫遍历整个互联网。然而，随着互联网站点的急剧增加，即使几十年前，现有的搜索引擎也已经无法完成对所有网站的遍历。因此，如何进行搜索引擎优化（Search Engine Optimization，SEO）已逐渐成为备受关注的研究领域。其目的是解决如何使搜索引擎更好地“阅读”我的网站，从而使我的博客文章在用户输入特定关键词时排在前列。在这篇文章中，我将逐步描述我如何对我的博客网站进行SEO，并提供相应的参考资料，希望能够对写博客的朋友提供帮助。&lt;/p&gt;
&lt;p&gt;首先，让我简单介绍一下我是如何搭建自己的博客的。如果你使用与我相似的工具链，那么本文将更有助于你。为了减少麻烦的事情，我主要使用GitHub Pages来部署和托管我的博客，这样就省去了很多麻烦。在框架方面，我使用的是&lt;a href="https://getpelican.com"&gt;Pelican&lt;/a&gt;，一个Python的静态文档站框架，并使用&lt;a href="https://github.com/alexandrevicenzi/Flex"&gt;Flex主题&lt;/a&gt;。Pelican支持Markdown写作，并且可以内嵌HTML。使用这套工具链，我几乎不需要担心部署和配置的问题，只需专注于写作即可。&lt;/p&gt;
&lt;h2&gt;获取访问数据&lt;/h2&gt;
&lt;p&gt;数据分析是进行优化的重要依据。即使你还没有开始优化，也应该了解如何获取有关你网站访问的数据。在本节中，我将介绍我如何查看访问数据，并提供一些我会用到的工具。&lt;/p&gt;
&lt;h3&gt;Google Analytics&lt;/h3&gt;
&lt;p&gt;使用&lt;a href="https://analytics.google.com/analytics/web/#/"&gt;Google Analytics&lt;/a&gt;，可以直观地查看网站的访问数据和高级浏览数据。我使用的Flex框架原生支持Google Analytics 4，只需要配置测量ID，即可在发布网站时自动添加相关的跟踪代码。&lt;/p&gt;
&lt;p&gt;首先，需要在Google Analytics后台配置网站跟踪，跟着步骤操作即可，可以参考&lt;a href="https://support.google.com/analytics/answer/1008080"&gt;官方指南&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然后，在你的网站页面中进行配置，才能收集数据，可以跟着这份&lt;a href="https://support.google.com/analytics/answer/9539598"&gt;官方教程&lt;/a&gt;拿到你的gtag。如果你使用Flex框架，可以直接在配置文件&lt;code&gt;pelicanconf.py&lt;/code&gt;中添加以下行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# pelicanconf.py&lt;/span&gt;
&lt;span class="c1"&gt;# Google analytics&lt;/span&gt;
&lt;span class="n"&gt;GOOGLE_GLOBAL_SITE_TAG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;G-XXXXXXXXXX&amp;#39;&lt;/span&gt; &lt;span class="c1"&gt;# Your Google Analytics 4 Property ID&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;原理也比较简单，就是在需要追踪的每个页面的HTML &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;里面加上google的信息。即使你没有跟我用一样的技术栈，你也可以用类似的方式处理，具体可以参考官方文档。这里给出一份模版代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="cm"&gt;&amp;lt;!-- Other heads --&amp;gt;&lt;/span&gt;

    {% if GOOGLE_GLOBAL_SITE_TAG %}
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt; &lt;span class="na"&gt;async&lt;/span&gt; &lt;span class="na"&gt;src&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;https://www.googletagmanager.com/gtag/js?id={{ GOOGLE_GLOBAL_SITE_TAG }}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;dataLayer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;window&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;dataLayer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gtag&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="nx"&gt;dataLayer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;gtag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;js&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;gtag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;config&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;{{ GOOGLE_GLOBAL_SITE_TAG }}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;script&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    {% endif %}
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样过一阵子就可以看到你的网站放完数据了。&lt;/p&gt;
&lt;h3&gt;Google Search Console&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;NOTE:&lt;/em&gt;&lt;/strong&gt; 建议生成好sitemap之后再进行这一步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://search.google.com/search-console/about"&gt;Google Search Console&lt;/a&gt; 是一个进阶的免费工具，可以用来查看网站在Google搜索结果中的排名和可见性，也包括了能指出网站问题的SEO工具等。&lt;/p&gt;
&lt;p&gt;跟着Google Search Console的配置器走，就会要求你&lt;a href="https://support.google.com/webmasters/answer/9008080?hl=en"&gt;验证你是这个网站的拥有者&lt;/a&gt;。验证的方式有很多种，这里我选择了最简单的一种，在网址根目录下放置提供的文件&lt;code&gt;/googleXXXXXXXXXXXX.html&lt;/code&gt;，里面就只有一行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;google-site-verification: googleXXXXXXXXXXXX.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在Pelican配置中也比较简单，直接讲这个文件加到配置文件&lt;code&gt;pelicanconf.py&lt;/code&gt;的&lt;code&gt;EXTRA_PATH_METADATA&lt;/code&gt;里面就好，比如这样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;EXTRA_PATH_METADATA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;static/google72cb1b82695f07e2.html&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;path&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;google72cb1b82695f07e2.html&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;发布之后就可以继续在Google Search Console里面完成配置。之后过几个小时就可以查看被搜索和点击到的次数了。&lt;/p&gt;
&lt;p&gt;当然，Google Search Console只针对Google的搜索，如果你想要配置其他搜索引擎，就需要另外配置了。比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.bing.com/webmasters"&gt;Bing Webmaster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ziyuan.baidu.com/"&gt;百度搜索平台&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;我的优化策略&lt;/h2&gt;
&lt;h3&gt;Pelican seo插件&lt;/h3&gt;
&lt;p&gt;顾名思义，&lt;a href="https://github.com/pelican-plugins/seo"&gt;&lt;code&gt;pelican-plugin/seo&lt;/code&gt;&lt;/a&gt;插件就是用来做Pelican框架下的SEO优化的。这个插件主要有两个功能
- SEO Report: 根据编译后的文章生成一个SEO报告，报告中包含SEO的几个关键点以及如何进行优化。
- SEO Enhancer：在文章编译时添加一些SEO元素，使得文章能够更好地被解析。&lt;/p&gt;
&lt;p&gt;安装&lt;code&gt;pelican-plugin/seo&lt;/code&gt;后，需要在&lt;code&gt;pelicanconf.py&lt;/code&gt;中增加相应的配置，包括：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="c1"&gt;# ...&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;seo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="c1"&gt;# SEO Settings&lt;/span&gt;
&lt;span class="n"&gt;SEO_REPORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;  &lt;span class="c1"&gt;# SEO report is enabled by default&lt;/span&gt;
&lt;span class="n"&gt;SEO_ENHANCER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;# SEO enhancer is disabled by default&lt;/span&gt;
&lt;span class="n"&gt;SEO_ENHANCER_OPEN_GRAPH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;# Subfeature of SEO enhancer&lt;/span&gt;
&lt;span class="n"&gt;SEO_ENHANCER_TWITTER_CARDS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;# Subfeature of SEO enhancer&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;简单介绍一下这几个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SEO_REPORT&lt;/code&gt;：生成上述提到的SEO报告，并以HTML形式输出在项目根目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEO_ENHANCER&lt;/code&gt;：添加一些默认的SEO元素，例如生成robots.txt，增加Canonical标签以及增加页面结构标签等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEO_ENHANCER_OPEN_GRAPH&lt;/code&gt;：开启Open Graph协议，能够在社交媒体上分享你的内容时显示额外的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SEO_ENHANCER_TWITTER_CARDS&lt;/code&gt;：开启Twitter卡片，能够在推特上分享你的内容时显示额外的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Pelican sitemap插件&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/pelican-plugins/sitemap"&gt;&lt;code&gt;pelican-plugin/sitemap&lt;/code&gt;&lt;/a&gt;能帮助你在生成Pelican静态网站的同时生成站点地图文件。这个文件可以向搜索引擎提供一些提示，帮助爬虫找到页面的路径并规划何时重新访问你的页面。一旦启用该插件，站点地图文件将在 &lt;code&gt;output/sitemap.&amp;lt;format&amp;gt;&lt;/code&gt; 路径下生成。
0
当你发布你的站点后，你需要将站点地图提交到搜索引擎后台。下面是一个在 Google Search Console 中添加站点地图的示例：&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/7/search_console_sitemap.png" /&gt;
&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;本文主要参考了&lt;a href="https://blog.kmonsoor.com/pelican-how-to-make-seo-friendly/"&gt;Pelican Static sites - SEO Optimization&lt;/a&gt;中聊的一些思路。&lt;/p&gt;
&lt;p&gt;如果你想变得更强的话，可以延伸看看&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/denzildoyle/31fe294065f606b4f612"&gt;SEO - denzildoyle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://kucw.github.io/blog/2021/1/from-medium-to-github/"&gt;為了 SEO！我離開了 Medium，改在 GitHub 上自架個人網站&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="MISC"></category></entry><entry><title>【Leetcode题解】2584. Split the Array to Make Coprime Products</title><link href="https://mestrace.github.io/posts/2023/Mar/08/2584-split-the-array-to-make-coprime-products/" rel="alternate"></link><published>2023-03-08T00:00:00+08:00</published><updated>2023-03-08T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-03-08:/posts/2023/Mar/08/2584-split-the-array-to-make-coprime-products/</id><summary type="html">&lt;p&gt;又闲的无聊，找点事情做，来写一下&lt;a href="https://leetcode.com/problems/split-the-array-to-make-coprime-products/"&gt;2584. Split the Array to Make Coprime Products&lt;/a&gt;的题解。&lt;/p&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are given a 0-indexed integer array &lt;code&gt;nums&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A split at an index i where &lt;code&gt;0 &amp;lt;= i &amp;lt;= n - 2&lt;/code&gt; is …&lt;/p&gt;</summary><content type="html">&lt;p&gt;又闲的无聊，找点事情做，来写一下&lt;a href="https://leetcode.com/problems/split-the-array-to-make-coprime-products/"&gt;2584. Split the Array to Make Coprime Products&lt;/a&gt;的题解。&lt;/p&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are given a 0-indexed integer array &lt;code&gt;nums&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A split at an index i where &lt;code&gt;0 &amp;lt;= i &amp;lt;= n - 2&lt;/code&gt; is called valid if the product of the first &lt;code&gt;i + 1&lt;/code&gt; elements and the product of the remaining elements are coprime.&lt;/p&gt;
&lt;p&gt;For example, if &lt;code&gt;nums = [2, 3, 3]&lt;/code&gt;, then a split at the index &lt;code&gt;i = 0&lt;/code&gt; is valid because &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt; are coprime, while a split at the index &lt;code&gt;i = 1&lt;/code&gt; is not valid because &lt;code&gt;6&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are not coprime. A split at the index &lt;code&gt;i = 2&lt;/code&gt; is not valid because &lt;code&gt;i == n - 1&lt;/code&gt;.
Return the smallest index &lt;code&gt;i&lt;/code&gt; at which the array can be split validly or &lt;code&gt;-1&lt;/code&gt; if there is no such split.&lt;/p&gt;
&lt;p&gt;Two values &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;val2&lt;/code&gt; are coprime if &lt;code&gt;gcd(val1, val2) == 1&lt;/code&gt; where &lt;code&gt;gcd(val1, val2)&lt;/code&gt; is the greatest common divisor of &lt;code&gt;val1&lt;/code&gt; and &lt;code&gt;val2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;给一个列表的数字，把这个列表分为两半，使得两边的乘积互质(coprime)。当然啦，要找那个使得左边最小的。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;这道题是2023.03.05的&lt;a href="https://leetcode.com/contest/weekly-contest-335/"&gt;周赛&lt;/a&gt;第三题。刚看到题目的时候我心想：“呵，简单！prefix sum(product)可破。”现在想想自己还是图样图森破了。首先要注意的是那个乘积，一看到n个数需要乘起来就需要立马联想到数字越界的问题。对于Python的盲目相信让我冲昏了头脑，用了各种魔改的prefix sum去试。比如先把数字预处理一遍，去除他们的乘数。当然事实证明我并没有办法解决这个问题。&lt;/p&gt;
&lt;p&gt;我第二个思路是图的思路。因为我们要把这个数组分为两个集合。如果两个数&lt;code&gt;gcd(a,b) != 1&lt;/code&gt;的话那么他们必定在同一个集合里面。那么，我们要先用&lt;code&gt;gcd&lt;/code&gt;构建他们的图…… 诶等一下，如果我要把每两个数字对比一遍找&lt;code&gt;gcd&lt;/code&gt;的话，时间复杂度好像是&lt;code&gt;O(n^2)&lt;/code&gt;…… 当然，你肯定猜到结局了，愚蠢的我用了这个方法且TLE了。&lt;/p&gt;
&lt;p&gt;最后，我光荣的成为了一名两题选手 ：）&lt;/p&gt;
&lt;p&gt;不说伤心事儿了。解决这题，首先需要注意的就是互质的性质。对于互质的两个数&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;来说，&lt;code&gt;b&lt;/code&gt;的所有质因数都不是&lt;code&gt;a&lt;/code&gt;的因数。我们知道，每一个正整数都可以表示成一些质数的乘积。
进一步思考，如果我们能够对每个数字进行质数分解，那么对于左右两边进行质数分解之后，就可以通过对比两遍的质数来检查两边是否互质了。&lt;/p&gt;
&lt;p&gt;当然这样还不够，因为找一个给定数字的质数也是一个不小的活儿。这里随便偷一段代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt;

&lt;span class="c1"&gt;# A function to print all prime factors of&lt;/span&gt;
&lt;span class="c1"&gt;# a given number n&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;prime_factors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Print the number of two&amp;#39;s that divide n&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

    &lt;span class="c1"&gt;# n must be odd at this point&lt;/span&gt;
    &lt;span class="c1"&gt;# so a skip of 2 ( i = i + 2) can be used&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

        &lt;span class="c1"&gt;# while i divides n , print i and divide n&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;

    &lt;span class="c1"&gt;# Condition if n is a prime&lt;/span&gt;
    &lt;span class="c1"&gt;# number greater than 2&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到，这个naive的方法是这么计算的：给定数字&lt;code&gt;n&lt;/code&gt;，循环[[2,√n]次去除这个数，如果能整除就说明n是这个数字的一个质因数，直到这个数字为1为止。因为我们的值域是&lt;code&gt;1 &amp;lt;= nums[i] &amp;lt;= 10^6&lt;/code&gt;，所以每个数字要循环&lt;code&gt;10^3&lt;/code&gt;次。哎，不得行不得行…… 等下，如果我们知道取值范围的话，那么直接打表不就好了！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;prime_factors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;primes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;47&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;59&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;61&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;71&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;73&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;83&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;89&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;97&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;103&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;107&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;109&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;113&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;131&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;137&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;139&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;149&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;151&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;157&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;163&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;167&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;173&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;179&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;181&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;191&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;193&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;197&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;199&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;211&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;223&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;227&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;229&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;233&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;239&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;241&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;251&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;257&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;263&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;269&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;271&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;277&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;281&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;283&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;293&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;307&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;311&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;313&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;317&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;331&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;337&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;347&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;349&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;353&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;359&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;367&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;373&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;379&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;383&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;389&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;397&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;401&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;409&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;419&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;421&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;431&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;433&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;439&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;443&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;449&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;457&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;461&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;463&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;467&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;479&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;487&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;491&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;499&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;503&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;509&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;521&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;523&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;541&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;547&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;557&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;563&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;569&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;571&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;577&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;587&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;593&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;599&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;601&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;607&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;613&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;617&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;619&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;631&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;641&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;643&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;647&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;653&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;659&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;661&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;673&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;677&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;683&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;691&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;701&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;709&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;719&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;727&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;733&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;739&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;743&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;751&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;757&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;761&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;769&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;773&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;787&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;797&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;809&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;811&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;821&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;823&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;827&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;829&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;839&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;853&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;857&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;859&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;863&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;877&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;881&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;883&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;887&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;907&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;911&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;919&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;929&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;937&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;941&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;947&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;953&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;967&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;971&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;977&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;983&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;991&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;997&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;factors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;primes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;primes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;primes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;primes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;factors&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;primes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;//=&lt;/span&gt; &lt;span class="n"&gt;primes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;factors&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;factors&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里我们直接搞个小于1000的质数表。然后一直尝试整除这些质数就好。这样就把我们的复杂度大大降低了。当然这个算法对于超过1000的质数也是有用的，因为最后如果n还是不为1的话，那么剩下那个数还是他的质因数。因为我们知道取值范围不可能出现超过两个 &amp;gt; 1000的指数，以最接近1000的两个为例，&lt;code&gt;1009 * 1013 = 1,022,117&lt;/code&gt;，而&lt;code&gt;1009 * 991 = 999,919&lt;/code&gt;。这个算法能保证在这个情况下我们是安全的。&lt;/p&gt;
&lt;p&gt;那么剩下的就简单了。回到我们的算法，从左到右，每次比较左右两边的质因数的交集就可以解决了。&lt;/p&gt;
&lt;h2&gt;解法&lt;/h2&gt;
&lt;p&gt;贴上剩余部分的代码。我们维护&lt;code&gt;left&lt;/code&gt;和&lt;code&gt;right&lt;/code&gt;两边的prime然后算交集。每次循环我们都给&lt;code&gt;left&lt;/code&gt;的质数数上，&lt;code&gt;right&lt;/code&gt;的质数扣掉，再比较他们两个的&lt;code&gt;key&lt;/code&gt;的交集就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;findValidSplit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;dec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;


        &lt;span class="n"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prime_factors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
            &lt;span class="n"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prime_factors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

        &lt;span class="c1"&gt;# print(left)&lt;/span&gt;
        &lt;span class="c1"&gt;# print(right)&lt;/span&gt;

        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;# print(left, right)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
            &lt;span class="n"&gt;dec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prime_factors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
            &lt;span class="n"&gt;inc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prime_factors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/gei_li.png" /&gt;
&lt;/p&gt;

&lt;p&gt;如果你看到这里了，再告诉你一点加强版的方案。&lt;/p&gt;
&lt;p&gt;实际上，left是一直在增加没有减少，所以我们也不需要维护left的count了，直接一个set然后每次取并集就可以了。这样可以减少一点内存消耗和一丢丢时间复杂度。&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/gei_li.png" /&gt;
&lt;/p&gt;

&lt;p&gt;实际上我们把大部分数字的质因数都求了两遍，因此如果我们能消耗一些内存把每个数字的质因数都保存下来的话，这样就会把常数部分的时间减少一半以上。&lt;/p&gt;
&lt;p&gt;用Python的朋友一定熟悉我们的好朋友&lt;code&gt;functools.cache&lt;/code&gt;。直接给我们的&lt;code&gt;prime_factors&lt;/code&gt;方法带上小帽子，实测有接近50%的速度提升（2801ms vs. 5300ms），而代价则是5MB的内存消耗（21.2MB vs. 16.2MB）。&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/gei_li.png" /&gt;
&lt;/p&gt;

&lt;p&gt;在这个方法里面，我们已经遍历了每一个数字的质因数。所以我们还是可以用类似图的方式去找。对于每一个质因数，如果我们知道他最早和最晚出现在数组的哪一个位置，那么我们就可以通过这样的方式去把这个数组一分为二了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;Explanation&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-----|&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;|----&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;|------&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上面这个例子里面，横线为每个质因数的区间，而竖线就是他的分界线。我们可以追着这个索引找到最左边的分界线，就是我们的结果了。想要参考代码的可以看看&lt;a href="https://leetcode.com/problems/split-the-array-to-make-coprime-products/solutions/3258070/prime-intervals-vs-count-primes/?orderBy=most_votes"&gt;v神的题解&lt;/a&gt;，这里就不多赘述了。&lt;/p&gt;
&lt;p&gt;又及：这个做法其实跟一天前的&lt;a href="https://leetcode.com/contest/biweekly-contest-99"&gt;双周赛&lt;/a&gt;的第三题&lt;a href="https://leetcode.com/problems/count-ways-to-group-overlapping-ranges/description/"&gt;2580. Count Ways to Group Overlapping Ranges&lt;/a&gt;的思路非常相似了（&lt;a href="https://mestrace.github.io/posts/2023/Mar/14/2580-count-ways-to-group-overlapping-ranges/"&gt;我的解法&lt;/a&gt;）。难怪讨论区里的人都说周赛和双周赛的出题人是同一个呢……&lt;/p&gt;
&lt;h2&gt;拓展&lt;/h2&gt;
&lt;p&gt;如果你想变得更强的话，可以延伸看看&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.cs.sfu.ca/~ggbaker/zju/math/primes.html"&gt;Primes and GCD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://maochong.xin/posts/euler_totient.html"&gt;欧拉函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/47978393"&gt;理解黎曼猜想（二）两个自然数互质的概率是多少？|袁岚峰&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="Leetcode"></category><category term="Contest"></category><category term="Math"></category></entry><entry><title>【Leetcode题解】2444. Count Subarrays With Fixed Bound</title><link href="https://mestrace.github.io/posts/2023/Mar/04/2444-count-subarrays-with-fixed-bounds/" rel="alternate"></link><published>2023-03-04T00:00:00+08:00</published><updated>2023-03-04T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-03-04:/posts/2023/Mar/04/2444-count-subarrays-with-fixed-bounds/</id><summary type="html">&lt;p&gt;今天闲的无聊，找点事情做，来写一下&lt;a href="https://leetcode.com/problems/count-subarrays-with-fixed-bounds/"&gt;2444. Count Subarrays With Fixed Bound&lt;/a&gt;的题解。&lt;/p&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are given an integer array &lt;code&gt;nums&lt;/code&gt; and two integers &lt;code&gt;minK&lt;/code&gt; and &lt;code&gt;maxK&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;fixed-bound subarray&lt;/strong&gt; of &lt;code&gt;nums&lt;/code&gt; is a subarray that satisfies the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今天闲的无聊，找点事情做，来写一下&lt;a href="https://leetcode.com/problems/count-subarrays-with-fixed-bounds/"&gt;2444. Count Subarrays With Fixed Bound&lt;/a&gt;的题解。&lt;/p&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are given an integer array &lt;code&gt;nums&lt;/code&gt; and two integers &lt;code&gt;minK&lt;/code&gt; and &lt;code&gt;maxK&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;fixed-bound subarray&lt;/strong&gt; of &lt;code&gt;nums&lt;/code&gt; is a subarray that satisfies the following conditions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;minimum&lt;/strong&gt; value in the subarray is equal to &lt;code&gt;minK&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;maximum&lt;/strong&gt; value in the subarray is equal to &lt;code&gt;maxK&lt;/code&gt;.
Return the number of fixed-bound subarrays.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A subarray is a contiguous part of an array.&lt;/p&gt;
&lt;p&gt;给定一个数字列表和一个最大值和一个最小值，找到所有区间满足最大值和最小值分别等于给定值的子数组的数量。&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;这道题是2022.10.16的&lt;a href="https://leetcode.com/contest/weekly-contest-315/"&gt;周赛&lt;/a&gt;题目。当时尝试用暴力dp的方式去解。思路是说用放宽约束条件的方式，去计算一个区间&lt;code&gt;[i,j]&lt;/code&gt;内是否都是在&lt;code&gt;[minK, maxK]&lt;/code&gt;内的数字，然后数一遍。果不其然TLE了。但今天不是周赛，我们有充足的时间去思考，别有太大压力。做这类数连续子数组类型的题目，首先看数据量。这道题数据量&lt;code&gt;10^5&lt;/code&gt;，也就意味着我们要在&lt;code&gt;O(n)&lt;/code&gt;的方式去解决，否则一定超时。因此，头脑里冒出来的第一个方式一定是双指针。&lt;/p&gt;
&lt;p&gt;先解决核心问题。假设我们已经知道怎么移动指针，并找到了满足条件的区间&lt;code&gt;[i,j]&lt;/code&gt;。也就是说&lt;code&gt;[i,j]&lt;/code&gt;区间的最大值等于&lt;code&gt;maxK&lt;/code&gt;，最小值等于&lt;code&gt;minK&lt;/code&gt;。那么我们要怎么计算这个区间内的子数组数量呢？这就可以引导我们去找到另外两个变量，我们要知道区间&lt;code&gt;[i,j]&lt;/code&gt;内的区间&lt;code&gt;[k,l]&lt;/code&gt;，使得&lt;code&gt;nums[k]&lt;/code&gt;和&lt;code&gt;nums[l]&lt;/code&gt;分别等于最大值和最小值（或反过来）。这样的话我们就找到了我们需要的变量。&lt;/p&gt;
&lt;p&gt;那么如何计算子数组的数量呢？我们先来看几个例子。&lt;/p&gt;
&lt;p&gt;先来个基础的例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;maxK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们尝试往里面加一个元素&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;maxK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;Explanation&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;多加两个元素，我们有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;maxK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;Explanation&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再增加一点难度，假设我们在区间内有多个符合条件的区间，这时候怎么办呢。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;maxK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;Output&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;Explanation&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="n"&gt;Starting&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;Starting&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因此，我们来总结一下规律。先说下我们已知的变量：&lt;code&gt;[i,j]&lt;/code&gt;为整个区间，&lt;code&gt;[k,l]&lt;/code&gt;为使得&lt;code&gt;nums[k]&lt;/code&gt;和&lt;code&gt;nums[l]&lt;/code&gt;分别等于最大值和最小值（或反过来)的区间，&lt;code&gt;nums[x]&lt;/code&gt;为我们当前看到的这个元素。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果在&lt;code&gt;minK &amp;lt;= nums[x] &amp;lt;= maxK&lt;/code&gt;，之前已经找到了区间&lt;code&gt;[k,l]&lt;/code&gt;，那么能和&lt;code&gt;x&lt;/code&gt;组成的子数组数量为&lt;code&gt;k - i + 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以参照上面第四个例子。当我们看到&lt;code&gt;4&lt;/code&gt;的时候，我们可以组成&lt;code&gt;[2,6,4]&lt;/code&gt;和&lt;code&gt;[3,2,6,4]&lt;/code&gt;。当我们看到最后一个&lt;code&gt;2&lt;/code&gt;的时候，前面有&lt;code&gt;[3,2,6]&lt;/code&gt;可以组成3个子数组。
1. 在规律1的基础上，当&lt;code&gt;nums[x] == minK or maxK&lt;/code&gt;的时候，我们需要更新区间&lt;code&gt;[k,l]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这里这道题的核心部分已经解决了，那么我们来看看如何移动指针。假设我们有指针&lt;code&gt;[left, right]&lt;/code&gt;，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们持续移动右指针&lt;code&gt;right&lt;/code&gt;，就像刚刚我们移动&lt;code&gt;x&lt;/code&gt;变量。&lt;/li&gt;
&lt;li&gt;之前我们假设的是我们已经能够找到区间&lt;code&gt;[i,j]&lt;/code&gt;。所以我们在看到不符合条件的&lt;code&gt;x&lt;/code&gt;使得&lt;code&gt;nums[x] &amp;lt; minK or nums[x] &amp;gt; maxK&lt;/code&gt;之前，&lt;code&gt;i&lt;/code&gt;都是保持不变的，因此这就是我们的左指针&lt;code&gt;left&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当我们找到不符合区间条件位置的&lt;code&gt;nums[right]&lt;/code&gt;的时候，我们就需要把之前的所有东西废弃掉，重新开始新一轮的匹配。&lt;/p&gt;
&lt;p&gt;举个简单的例子我们可以想象这个数组为&lt;code&gt;nums = ...[i_1, j_1]...[i_2, j_2]...&lt;/code&gt;，这样的话当我们移动到&lt;code&gt;...&lt;/code&gt;里不符合条件的&lt;code&gt;nums[right]&lt;/code&gt;的时候，我们就不能用刚刚的规则继续匹配了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到这里，我们就把所有需要理解的逻辑都捋顺了。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;countSubarrays&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;lastmin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;lastmax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;minK&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;maxK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;
                &lt;span class="n"&gt;lastmin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="n"&gt;lastmax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
                &lt;span class="k"&gt;continue&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;lastmin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;maxK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;lastmax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;lastmin&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;lastmax&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lastmin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lastmax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里跟上述逻辑有略微不一样的是，我们每次把不符合条件的地方当作&lt;code&gt;left&lt;/code&gt;开始的地方，这样逻辑更加简洁。&lt;/p&gt;</content><category term="Leetcode"></category><category term="Contest"></category><category term="Subarray"></category></entry><entry><title>[翻译]保卫自由的互联网，拒绝Web3</title><link href="https://mestrace.github.io/posts/2023/Feb/18/translate-no-to-web3/" rel="alternate"></link><published>2023-02-18T00:00:00+08:00</published><updated>2023-02-18T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-02-18:/posts/2023/Feb/18/translate-no-to-web3/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文标题：Keep the web free, say no to Web3&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href="https://yesterweb.org/no-to-web3/"&gt;https://yesterweb.org/no-to-web3/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新的想法，新的思潮，下一代互联网，Web3对每个人的意义都是独一无二的。币圈的铁杆粉丝们把这种基于区块 …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;原文标题：Keep the web free, say no to Web3&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href="https://yesterweb.org/no-to-web3/"&gt;https://yesterweb.org/no-to-web3/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新的想法，新的思潮，下一代互联网，Web3对每个人的意义都是独一无二的。币圈的铁杆粉丝们把这种基于区块链技术的互联网称之为“未来”。无论如何，本文将会实事求是地讨论和分析Web3的所有问题。&lt;/p&gt;
&lt;h2&gt;Web3用猎奇的营销手段进行宣传&lt;/h2&gt;
&lt;p&gt;营销的目的是创造需求，激发人们的兴趣，以提升销量。营销人员的目的是销售商品，因此他们不会告诉消费者这些商品的底层机制。为了提高币价，币圈内的人们进行了自我营销，只是为了让自己的资产增值。&lt;/p&gt;
&lt;p&gt;正因如此，Twitter上的大部分Web3宣传都采用了猎奇的营销手段。这些宣传主要针对初学者、新手和加密货币人群，延续了庞氏骗局的思路。&lt;/p&gt;
&lt;p&gt;《庞氏骗局的政治学》的作者玛丽·施普林格在一次采访中回应了加密货币炒作，“我不能告诉你有多少庞氏骗局使用了你所描述的机制来进行炒作。唯一的区别通常是这些骗局使用的是法定货币。”&lt;/p&gt;
&lt;h2&gt;Web3制造了大量的信息不对称&lt;/h2&gt;
&lt;p&gt;在经济学中，信息不对称被定义为在市场交易中，一方拥有比另一方更多或更好的信息。那些可能会“输”的人由于缺乏时间、精力、资源或知识，无法保护自己。他们不明白自己要投资的东西，也无法判断是否应该这样做。&lt;/p&gt;
&lt;p&gt;如果一个网站以Web3为噱头发行代币或者使用代币，一般来说他们会滥用这种行为。就像黑帽子SEO&lt;sup id="sf-translate-no-to-web3-1-back"&gt;&lt;a href="#sf-translate-no-to-web3-1" class="simple-footnote" title="黑帽SEO是指通过作弊手段，让站点在搜索引擎中得到更好的排名"&gt;1&lt;/a&gt;&lt;/sup&gt;一样，只有不明就里的用户是受害者。&lt;/p&gt;
&lt;p&gt;区块链行业通过使用复杂和难懂的信息技术，造成了这种骗局，但同时也通过信息公开来阻止不明就里的人群加入。&lt;/p&gt;
&lt;h2&gt;Web3会导致进一步的环境破坏&lt;/h2&gt;
&lt;p&gt;加密货币行业最受诟病的一个问题就是，矿工们在进一步破坏本就岌岌可危的生态系统。区块链行业需要大量的算力，这也导致了巨大的能源消耗。一些矿工甚至包下整个发电厂来进行挖矿。&lt;/p&gt;
&lt;p&gt;剑桥大学的替代金融中心（Cambridge Centre for Alternative Finance）从2017年开始发布了剑桥比特币电力消耗指数（&lt;a href="https://ccaf.io/cbeci/index"&gt;Cambridge Bitcoin Electricity Consumption Index&lt;/a&gt;）。他们发现，全网比特币挖矿的能源消耗甚至超过了一些小国家。&lt;/p&gt;
&lt;p&gt;此外，气候灾害也会影响人们的生活，从而影响整个互联网。尽管许多人谴责区块链行业对环境的损害，但大多数人似乎忽略了这一点。随着气候变化引起的自然灾害的频率、强度和持续时间的不断增加，许多从业者可能无法应对。&lt;/p&gt;
&lt;h2&gt;Web3只是投机者和大鳄的幸存者偏差&lt;/h2&gt;
&lt;p&gt;在新项目发布时，创始人通常会展示项目以寻求融资，但公众并不知道该项目是否会成功。只有相信该项目的人才会投资。然而，当项目失败时，这些钱将无法返还。因此，那些投入资金最多的人通常也是最富有的人。当一个人身价过亿时，损失50万对他来说只是九牛一毛。当所有项目创始人都在筹款时，那些获得最多投资的项目更有可能成功。这也意味着，只有那些早期幸存者和投资者才能生存并发出最响亮的声音。&lt;/p&gt;
&lt;p&gt;虽然有些人认为加密货币是赚钱的方法，但史蒂芬·迪尔（Stephen Diehl）在最近的一次采访中将加密货币描述为“一种巨大的逆转税，将钱从穷人和文盲转移到早期采用者、投资者和技术人员。”他继续说道，“唯一真正的终极目标是重新创造已经存在的系统，只不过有新的控制者在掌控着它。”&lt;/p&gt;
&lt;p&gt;换句话说，那些最早进入市场的人、拥有更多资金的人、拥有更多信息和技术的人，将是Web3的最大受益者。Web3的世界将有更多的巨头和少数人获得更多的好处，而穷人和文盲将成为损失的一方。这只是新的技术革命的常见现象，但这并不意味着它是公平和可持续的。&lt;/p&gt;
&lt;h2&gt;Web3从人为制造的稀缺性获利&lt;/h2&gt;
&lt;p&gt;区块链行业从业者在技术应该提高生产力和共享力的前提下，却不断施加人为稀缺性以获取利益。&lt;/p&gt;
&lt;p&gt;有一篇新闻报道指出，“数字稀缺性”是一种反人类进化的意识形态，它强制执行类似棋盘游戏的规则，但这些规则并没有其他目的，只是为了维持这个游戏的存在。这些规则旨在掩盖资本主义内在的矛盾，而这种矛盾在已经摆脱稀缺性的Web2领域中变得更加刺眼。&lt;/p&gt;
&lt;p&gt;“炒作和抛售”是一种常见的加密货币诈骗方式。这种诈骗分为两个部分——第一部分是通过大量宣传来推高某个项目的价格（和需求）。然后，在代币价格上涨时，持币者将其抛售给那些相信它们真正有价值的人以获利。&lt;/p&gt;
&lt;h2&gt;Web3让投资人越陷越深&lt;/h2&gt;
&lt;p&gt;近来，越来越多的大型投资人开始关注这个行业，并投入了资金。他们拥有足够的财力和影响力来推广和推动Web3的普及。&lt;/p&gt;
&lt;p&gt;现在我们必须好好思考一下这个问题：我们真的需要Web3吗？或者只是因为一些已经投入了大量金钱的投资人不愿意承认自己的错误，而继续犯错，推广Web3？&lt;/p&gt;
&lt;h2&gt;写在最后&lt;/h2&gt;
&lt;p&gt;请记住：推动Web3和任何其他加密货币相关的人，都是从中获利的人。&lt;/p&gt;
&lt;p&gt;Web3只会进一步加剧社会和经济层次的分化。&lt;/p&gt;
&lt;p&gt;我们不必依靠Web3来建立一个更好、更自由、去中心化的互联网。&lt;/p&gt;
&lt;h3&gt;进一步阅读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://palladiummag.com/2022/01/21/when-the-stagnation-goes-virtual/"&gt;When the Stagnation Goes Virtual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://player.fm/series/tech-wont-save-us/web3-is-a-scam-not-a-revolution-w-stephen-diehl"&gt;Web3 is a Scam, Not a Revolution [Podcast]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web3isgoinggreat.com/"&gt;Web3 is [Not] Going Great&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=YQ_xWvX1n9g"&gt;The Problem with NFTs by Folding Ideas [Video]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.stephendiehl.com/blog/web3-bullshit.html"&gt;Web3 is Bullshit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gwennseemel.com/blog/2021/1216-web-free-point-oh/"&gt;Web Free Point Oh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.usenix.org/publications/loginonline/web3-fraud"&gt;Web3 Fraud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://soatok.blog/2021/10/19/against-web3-and-faux-decentralization/"&gt;Against Web3 and Faux Decentralization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://invisibleup.com/articles/38/"&gt;Web3 is Not Decentralization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/bugout-dev/moonstream/blob/main/datasets/nfts/papers/ethereum-nfts.pdf"&gt;An Analysis of 7,020,950 NFT Transactions on the Ethereum Blockchain&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://letslearntogether.neocities.org/compute/futureweb01.html"&gt;Future Web&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;更进一步阅读&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.consumer.ftc.gov/articles/what-know-about-cryptocurrency-and-scams"&gt;What to Know About Cryptocurrency Scams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.bloomberg.com/opinion/articles/2021-11-30/omicron-crypto-is-a-bet-on-attention"&gt;Omicron Crypto Is a Bet on Attention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mashable.com/article/influencers-altcoin-scams"&gt;Inside the Shady World of Influencers Promoting Cryptocurrency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.msn.com/en-us/money/other/an-nft-just-sold-for-532-million-but-didn-t-really-sell-at-all/ar-AAQ5nZY"&gt;An NFT just Sold for $532 mil but Didn't Really Sell at All&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.nature.com/articles/s41598-021-00053-8"&gt;Mapping the NFT Revolution: Market Trends, Trade Networks and Visual Features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ojs.bibsys.no/index.php/NIK/article/view/911"&gt;Bitcoin and Blockchain Security: A Study in Misconceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://rorodi.substack.com/p/the-biggest-crypto-lending-company"&gt;The Biggest Crypto-Lending Company is a Massive Scam&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全文完&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;一些个人的看法&lt;/h2&gt;
&lt;p&gt;Web3的革新预计不会在未来十年内发生。许多推动者和鼓吹者更加关心的是如何从中获利，而不是实现Free Web。并且，区块链行业的发展已经远离了中本聪的初衷。尽管该行业的口号是去中心化，但对于大多数人而言，最容易接触到的平台仍然是中心化的。比如币安自称是全球最大的加密资产交易平台。如果无法实现去中心化，那么Web3所满足的只会是资本，这将进一步加剧贫富差距。&lt;/p&gt;
&lt;hr&gt;&lt;ol class="simple-footnotes"&gt;&lt;li id="sf-translate-no-to-web3-1"&gt;黑帽SEO是指通过作弊手段，让站点在搜索引擎中得到更好的排名 &lt;a href="#sf-translate-no-to-web3-1-back" class="simple-footnote-back"&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</content><category term="Blockchain"></category><category term="Blockchain"></category></entry><entry><title>用 Python 进行代码覆盖率检测：coverage.py 和diff-cover 的使用方法</title><link href="https://mestrace.github.io/posts/2023/Feb/05/python-coverage-diff-cover/" rel="alternate"></link><published>2023-02-05T00:00:00+08:00</published><updated>2023-02-05T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-02-05:/posts/2023/Feb/05/python-coverage-diff-cover/</id><summary type="html">&lt;p&gt;在重构项目时，我们经常需要确认代码测试的覆盖率。这是为了确保没有任何部分遗漏或者错误，从而使重构变得更安全 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在重构项目时，我们经常需要确认代码测试的覆盖率。这是为了确保没有任何部分遗漏或者错误，从而使重构变得更安全。为了帮助我们实现这一目标，我们可以使用两个 Python 包来帮助我们 &lt;code&gt;coverage.py&lt;/code&gt; 和 &lt;code&gt;diff-cover&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;coverage.py&lt;/code&gt;是一个代码插桩工具，它能够生成测试覆盖率报告。它的官方仓库是https://github.com/nedbat/coveragepy。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;diff-cover&lt;/code&gt;则是一个比对xml格式的coverage文件的工具，它能够将当前的覆盖率与origin/main或指定的commit进行比对。更多信息请参考它的官方仓库：https://github.com/Bachmann1234/diff_cover。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果您的测试运行命令以&lt;code&gt;python&lt;/code&gt;开头，只需要将初始的&lt;code&gt;python&lt;/code&gt;替换为&lt;code&gt;coverage run&lt;/code&gt;即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If your test runner command starts with “python”, just replace the initial “python” with “coverage run”.&lt;/p&gt;
&lt;p&gt;python something.py becomes coverage run something.py&lt;/p&gt;
&lt;p&gt;python -m amodule becomes coverage run -m amodule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在运行完覆盖率的脚本之后，你的项目目录中会多出一个.coverage的元数据文件。为了使结果更加直观，我们需要将其进一步解析为更有说服力的形式。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;coverage report --skip-covered --precision 2 --sort Cover&lt;/code&gt; 命令，你可以在命令行窗口中看到每一个文件的覆盖率情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Name&lt;span class="w"&gt;                             &lt;/span&gt;Stmts&lt;span class="w"&gt;   &lt;/span&gt;Miss&lt;span class="w"&gt;   &lt;/span&gt;Cover
-----------------------------------------------------
admin/models.py&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.00%
admin/views.py&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.00%
api/models.py&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.00%
api/views.py&lt;span class="w"&gt;                         &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.00%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过使用 &lt;code&gt;coverage html&lt;/code&gt; 命令，你还可以在项目目录中生成一个html文档站，以查看更详细的覆盖率信息，以及覆盖了哪些代码行。&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/1/coverage_html.jpeg" /&gt;
&lt;/p&gt;

&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/gei_li.png" /&gt;
&lt;/p&gt;

&lt;p&gt;在对一个巨大的代码库进行修改之后，整个项目的覆盖率并不会有明显的改变，同时也很难定位关注点。为了确保我们的代码修改已经被覆盖到，我们需要提升测试用例的覆盖率，如果没有覆盖到的话，我们需要补充测试用例。有人可能说，这很简单，只需要对比目标分支和当前分支的差异，再去看对应行是否已经被测试覆盖了。幸运的是，已经有人为我们开发了一个工具diff-cover（https://pypi.org/project/diff-cover/ ）。使用coverage.py和diff-cover结合，我们可以迅速找到未被覆盖到的代码。&lt;/p&gt;
&lt;p&gt;我们可以通过执行以下命令生成覆盖率报告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;coverage xml -o test.xml&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，我们可以使用diff-cover读取该报告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;diff-cover test.xml --compare-branch origin/master --html-report diff-cover.html&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，compare-branch参数需要指定用于与当前分支进行diff的分支，html-report参数则输出html格式的覆盖率报告。执行命令后，不仅会在命令行中输出类似如下的覆盖率信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-------------
Diff Coverage
Diff: origin/master...HEAD, staged and unstaged changes
-------------
account/controllers.py (76.5%): Missing lines 246,302,310,316
account/dao.py (90.3%): Missing lines 262,265,277
account/views.py (0.0%): Missing lines 179,187
-------------
Total:   50 lines
Missing: 9 lines
Coverage: 82%
-------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还会生成一个包含具体代码覆盖行的html文档&lt;/p&gt;
&lt;p align="center" width="50%" height="50%"&gt;
  &lt;img src="https://mestrace.github.io/images/1/diff_cover_html.jpeg" /&gt;
&lt;/p&gt;

&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/gei_li.png" /&gt;
&lt;/p&gt;

&lt;p&gt;在使用 &lt;code&gt;coverage.py&lt;/code&gt; 进行代码测试覆盖率报告时，我们可能会遇到包含不必要文件和行的情况。例如，Django 自动生成的 &lt;code&gt;manage.py&lt;/code&gt; 文件就不需要我们关注。同样地，代码行 &lt;code&gt;raise NotImplementedError&lt;/code&gt; 也没有什么意义。因此，我们需要将它们屏蔽，以提高代码测试覆盖率报告的精度。&lt;/p&gt;
&lt;p&gt;在运行 &lt;code&gt;coverage.py&lt;/code&gt; 时，可以使用 &lt;code&gt;omit=[pattern1,pattern2…]&lt;/code&gt; 选项忽略某些无关的文件，以及使用 &lt;code&gt;exclude_lines = [pattern1, pattern2]&lt;/code&gt; 选项忽略某些无关的行。例如，使用命令 &lt;code&gt;coverage run --omit="tests" --source='.' manage.py test --keepdb&lt;/code&gt; 可以忽略文件名包含 "tests" 的文件。&lt;/p&gt;
&lt;p&gt;不过，每次都要手动输入 &lt;code&gt;omit&lt;/code&gt; 和 &lt;code&gt;exclude-line&lt;/code&gt; 选项非常麻烦，因此我们可以在项目根目录下配置 &lt;code&gt;.coveragerc&lt;/code&gt; 文件，一次性配置所有选项。&lt;code&gt;.coveragerc&lt;/code&gt; 文件使用 toml 格式编写，在运行 &lt;code&gt;coverage run / coverage report / coverage html&lt;/code&gt; 命令时会读取其中的值并作为参数。&lt;/p&gt;
&lt;p&gt;以下是我在 django 项目中使用的 &lt;code&gt;.coveragerc&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[run]&lt;/span&gt;
&lt;span class="na"&gt;source&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;.&lt;/span&gt;
&lt;span class="na"&gt;omit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;./venv/,*tests,apps.py,*manage.py,_init_.py,migrations,asgi,wsgi,*admin.py,*urls.py&lt;/span&gt;

&lt;span class="k"&gt;[report]&lt;/span&gt;
&lt;span class="na"&gt;omit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;./venv/,*tests,apps.py,*manage.py,_init_.py,migrations,asgi,wsgi,*admin.py,*urls.py&lt;/span&gt;
&lt;span class="na"&gt;exclude_lines&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;pragma&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;no cover&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;def _repr_&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if self.debug&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if settings.DEBUG&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;raise AssertionError&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;raise NotImplementedError&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if 0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if _name_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;= ._main_.:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;class .*\bProtocol\)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;@(abc\.)?abstractmethod&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;coverage.py&lt;/code&gt; 的官方文档 https://coverage.readthedocs.io/en/7.1.0/&lt;/li&gt;
&lt;li&gt;&lt;code&gt;diff-cover&lt;/code&gt; 的官方文档 https://diff-cover.readthedocs.io/en/latest/README.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.coveragerc&lt;/code&gt; 文件来自 https://stackoverflow.com/questions/1628996/is-it-possible-exclude-test-directories-from-coverage-py-reports&lt;/li&gt;
&lt;li&gt;&lt;code&gt;coverage.py&lt;/code&gt; 的 Django 插件 https://pypi.org/project/django-coverage-plugin/&lt;/li&gt;
&lt;/ol&gt;</content><category term="Python"></category><category term="Python"></category></entry><entry><title>RocketMQ是什么</title><link href="https://mestrace.github.io/posts/2021/Sep/11/rocket-mq-history/" rel="alternate"></link><published>2021-09-11T00:00:00+08:00</published><updated>2021-09-11T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2021-09-11:/posts/2021/Sep/11/rocket-mq-history/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;Apache RocketMQ is a distributed messaging and streaming platform with low latency, high performance and reliability, trillion-level capacity and flexible scalability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RocketMQ 是一个分布式消息中间件，其具有低延迟、高性能和可靠性、万亿级容 …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;Apache RocketMQ is a distributed messaging and streaming platform with low latency, high performance and reliability, trillion-level capacity and flexible scalability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RocketMQ 是一个分布式消息中间件，其具有低延迟、高性能和可靠性、万亿级容量、灵活的可扩展性特性。&lt;/p&gt;
&lt;p&gt;&lt;img alt="异构数据下的ETL(Extract, Transform and Load) 处理" src="https://mestrace.github.io/images/2/etl_process.png"&gt;&lt;/p&gt;
&lt;p&gt;Kafka诞生于所谓的“大数据”时代的早期, 本质是LinkedIn为了解决在不同子系统中进行日志流同步的产物. 在设计之初就专注于对于解决ETL(Extract, transform, and load) 场景连续, 大量的消息数据的生产与消费. 作为一个通用场景的MQ系统, Kafka在大数据领域的实时计算以及日志采集领域被大规模使用. 基于Kafka, LinkedIn构建了一个以日志为中心的大规模分布式系统. 每天产生超过600亿条数据. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Kafka在LinkedIn的使用场景" src="https://mestrace.github.io/images/2/linkedin_kafka_usage.png"&gt;&lt;/p&gt;
&lt;p&gt;无疑, 基于MQ构建的数据驱动的系统给业务上带来了各种各样的便利和简化. 越来越多的开发者基于Kafka来构建各种应用. 随着时间的推移, 大量的使用也暴露了Kafka的在不同场景下的缺陷, 例如缺乏重试机制, 非严格顺序消费, 和不支持分布式事务. 因此, 阿里巴巴中间件团队针对订单, 交易和充值场景下对于MQ的使用进行了优化, 并与Apache基金会一起开源了RocketMQ. RocketMQ在淘宝的各种活动场景经历了大量的考验. 2017年, 阿里巴巴将RocketMQ开源并捐赠给Apache基金会, 由社区进行维护.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Rocket MQ的历史" src="https://mestrace.github.io/images/2/kafka_history.png"&gt;&lt;/p&gt;
&lt;p&gt;一个有意思的点: RocketMQ项目只维护核心功能，且去除了所有其他运行时依赖，核心功能最简化。每个BU的个性化需求都在RocketMQ项目之上进行深度定制。RocketMQ向其他BU提供的仅仅是Jar包，例如要定制一个Broker，那么只需要依赖rocketmq-broker这个jar包即可，可通过API进行交互，如果定制client，则依赖rocketmq-client这个jar包，对其提供的api进行再封装。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名词&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;生产组 Producer Group&lt;/td&gt;
&lt;td&gt;标识发送同一类消息的Producer，通常发送逻辑一致。发送普通消息的时候，仅标识使用，并无特别用处。 若事务消息，如果某条发送某条消息的producer-A宕机，使得事务消息一直处于PREPARED状态并超时，则broker会回查同一个group的其 他producer，确认这条消息应该commit还是rollback。但开源版本并不支持事务消息。 注: 字节RMQ暂不支持事务.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;消费组 Consumer Group&lt;/td&gt;
&lt;td&gt;标识一类Consumer的集合名称，这类Consumer通常消费一类消息，且消费逻辑一致。同一个Consumer Group下的各个实例将共同消费topic的消息，起到负载均衡的作用。 消费进度以Consumer Group为粒度管理，不同Consumer Group之间消费进度彼此不受影响，即消息A被Consumer Group1消费过，也会再给Consumer Group2消费。 注： RocketMQ要求同一个Consumer Group的消费者必须要拥有相同的注册信息，即必须要监听一样的topic(并且tag也一样)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Topic&lt;/td&gt;
&lt;td&gt;标识一类消息的逻辑名字，消息的逻辑管理单位。无论消息生产还是消费，都需要指定Topic。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tag&lt;/td&gt;
&lt;td&gt;RocketMQ支持给在发送的时候给topic打tag，同一个topic的消息虽然逻辑管理是一样的。但是消费topic1的时候，如果你订阅的时候指定的是tagA，那么tagB的消息将不会投递。 注: PPE泳道不是以这种方式实现的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;逻辑队列 Message Queue&lt;/td&gt;
&lt;td&gt;消息物理管理单位。一个Topic将有若干个Queue。若Topic同时创建在不通的Broker，则不同的broker上都有若干Queue，消息将物理地存储落在不同Broker结点上，具有水平扩展的能力。 无论生产者还是消费者，实际的生产和消费都是针对Queue级别。例如Producer发送消息的时候，会预先选择（默认轮询）好该Topic下面的某一条Queue地发送.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;集群消费&lt;/td&gt;
&lt;td&gt;消费者的一种消费模式。一个Consumer Group中的各个Consumer实例分摊去消费消息，即一条消息只会投递到一个Consumer Group下面的一个实例。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;广播消费&lt;/td&gt;
&lt;td&gt;消费者的一种消费模式。消息将对一个Consumer Group下的各个Consumer实例都投递一遍。即即使这些 Consumer 属于同一个Consumer Group，消息也会被Consumer Group 中的每个Consumer都消费一次。 注: 字节RMQ暂不支持广播消费&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="Middleware"></category><category term="RocketMQ"></category><category term="Kafka"></category></entry><entry><title>简单聊聊MySQL Binlog</title><link href="https://mestrace.github.io/posts/2021/Aug/30/mysql-binlog-basics/" rel="alternate"></link><published>2021-08-30T00:00:00+08:00</published><updated>2021-08-30T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2021-08-30:/posts/2021/Aug/30/mysql-binlog-basics/</id><summary type="html">&lt;p&gt;Binlog (binary log)是一组日志文件，包含了对MySQL服务器进行的数据修改和变更，并持久化到磁盘中。Binlog以事件的格式存储，包括了所有的DDL和DML语句（例如数据表Schema的创建和变更，以及数据行的变更）。此外，每个Binlog …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Binlog (binary log)是一组日志文件，包含了对MySQL服务器进行的数据修改和变更，并持久化到磁盘中。Binlog以事件的格式存储，包括了所有的DDL和DML语句（例如数据表Schema的创建和变更，以及数据行的变更）。此外，每个Binlog event还囊括了一些额外的信息，包括但不限于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语句执行时间&lt;/li&gt;
&lt;li&gt;语句执行时MySQL Server的相关状态&lt;/li&gt;
&lt;li&gt;错误码&lt;/li&gt;
&lt;li&gt;Binlog本身的元信息（如&lt;code&gt;rotate&lt;/code&gt;日志）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及其他所有能够让此Binlog event能够被准确的重放的信息。理想条件下，在两台MySQL服务器上同时执行相同的Binlog event，最终两台MySQL服务器里的数据状态一致。
Binlog的主要作用有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL集群中，对于主库的变更会通过Binlog同步到从库中。&lt;/li&gt;
&lt;li&gt;数据恢复的场景下，可以重放Binlog以将数据恢复到最新的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将主要介绍Binlog的文件格式和日志事件，并简单概括相关的应用场景。&lt;/p&gt;
&lt;h2&gt;文件格式&lt;/h2&gt;
&lt;figure align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/6/binlog-file.png" /&gt;
  &lt;figcaption&gt;Binlog的文件格式&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Binlog日志主要包括两类文件构成：一个日志索引（文件后缀为&lt;code&gt;.index&lt;/code&gt;）和数个日志文件（文件后缀为&lt;code&gt;.NNNNNN&lt;/code&gt;，&lt;code&gt;N&lt;/code&gt;为一个数字）。&lt;/li&gt;
&lt;li&gt;索引文件里包含了所有的日志文件的名称，并记录了当前活跃(Active)的日志文件（即当前最新的文件）&lt;/li&gt;
&lt;li&gt;日志文件首先以一个魔数开头，紧接着就是一系列包含DDL和DML的binlog events事件&lt;/li&gt;
&lt;li&gt;魔数：&lt;code&gt;0xfe 0x62 0x69 0x6e = 0xfe 'b''i''n'&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;日志文件的第一个事件总是&lt;code&gt;FORMAT_DESCRIPTION_EVENT / START_EVENT_V3&lt;/code&gt;，描述了当前日志文件的一些系统基准信息，包括Binlog的版本，MySQL Server的版本和文件创建时间。&lt;/li&gt;
&lt;li&gt;随后的事件则根据事件类型有所不同，主要是包含了对于数据的变更信息。&lt;/li&gt;
&lt;li&gt;最后，如果这个文件不是当前的活跃日志，则它会以一个&lt;code&gt;Rotate&lt;/code&gt;事件结束，并记录了下一个日志文件的名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/6/binlog-content.png" /&gt;
  &lt;figcaption&gt;Binlog的事件格式&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;除了相关的管理事件以外，包含数据更新的Binlog事件通常以日志组(Group)的形式出现（如上图）。一组事件包含一个或多个Binlog事件。一个事务中所有的语句会被归属到同一个日志组。而对于其他事务无关的语句来说（如ALTER TABLE，GRANT等），每一个语句会被归属于一个独立的日志组。当需要以Binlog为基础进行数据复制或恢复时，每个组会被顺序执行，且组中的语句要么全部成功，要么全部失败。&lt;/p&gt;
&lt;h2&gt;日志事件&lt;/h2&gt;
&lt;p&gt;Binlog主要有三种模式。
- 基于语句的模式(Statement-based，SBR)包含实际执行的SQL语句（如&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;）。
  - 缺点：不仅需要记录执行的语句，而且需要额外记录语句相关的状态信息，以保证重放的时候能够产生相同的结果。在极端情况下，一些非确定性(non-deterministic)的语句可能会产生与预期不一致的结果。
- 基于行的模式(Row-based，RBR)包含对于每一个数据行的变更。
  - 缺点：会产生大量的行语句，可能会引起磁盘性能问题，且恢复的时候需要更多的时间。
- 混合模式(Mixed， MBR)主要基于语句的模式，在一些不安全（unsafe）的场景下（见[4]），会切换为基于行的模式。
  - 在使用无法确定结果的&lt;code&gt;AUTO_INCREMENT&lt;/code&gt;，&lt;code&gt;LAST_INSERT_ID()&lt;/code&gt;或&lt;code&gt;TIMESTAMP&lt;/code&gt;时（见[5]）
  - 当function包含UUID()
  - 当使用储存过程的时候
基于语句和基于行的模式的更细节的对比见参考文献[3]。&lt;/p&gt;
&lt;figure align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/6/binlog-event-mindmap.png" /&gt;
  &lt;figcaption&gt;Binlog的事件类型&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;每一个事件都由事件头Header和事件体Event Data组成。
- 一个事件头有 19 字节，依次排列为：时间戳，事件类型，服务器ID，事件长度，下一个事件的byte offset，和标识符。
- 一个事件体由两部分组成，一个固定长度的Post-Header和一个可变长度的Payload组成。Post-Header的长度对于每一种事件来说是固定的，但是不同事件是不一样的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;+============+==========================+
|            |        Timestamp         |
|            |         4 bytes          |
|            +--------------------------+
|            |        Type Code         |
|            |          1 byte          |
|            +--------------------------+
|            |        Server ID         |
|            |         4 bytes          |
|   Header   +--------------------------+
|            |       Event Length       |
|            |         4 bytes          |
|            +--------------------------+
|            |      Next Position       |
|            |         4 bytes          |
|            +--------------------------+
|            |          Flags           |
|            |         2 bytes          |
+------------+--------------------------+
|            | Fixed Part (Post-Header) |
| Event Data +--------------------------+
|            | Variable Part (Payload)  |
+============+==========================+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当配置不同的Binlog模式时，储存的的Binlog事件不尽相同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些公共的事件，如管理事件，在所有模式下都会产生。&lt;/li&gt;
&lt;li&gt;Statement和Row模式下各有数种独特的事件。举个例子，ROWS_EVENT就不会出现在Statement模式下。&lt;/li&gt;
&lt;li&gt;只有在开启某些配置之后才会开启的事件，如GTID_EVENT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几种常见的事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FORMAT_DESCRIPTION_EVENT&lt;/code&gt; / &lt;code&gt;START_EVENT_V3&lt;/code&gt;：两种日志文件的起始事件，主要是根据Binlog版本不同而使用不同的事件。主要记录了Binlog版本号，MySQL Server版本号，开始时间。在Payload中会附带每种事件枚举值所对应的Post-Header长度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROTATE_EVENT&lt;/code&gt;：当日志文件需要切换时所记录的最后一个事件，保存了紧接着下一个日志文件名称。切换日志文件的条件：1）当前活跃的日志文件大小超过&lt;code&gt;max_binlog_size&lt;/code&gt;，或2）执行&lt;code&gt;flush logs;&lt;/code&gt;命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QUERY_EVENT&lt;/code&gt;：记录了被执行的SQL语句，相关的统计/debug信息（执行时间，thread id等），和相关的状态信息（是否需要auto increment，charset，tz等）。此事件通常记录的语句为：1）事务开始时的Begin操作，2）Statement模式下的DML操作，3）Row模式下的DDL操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE_ROWS_EVENT&lt;/code&gt; / &lt;code&gt;UPDATE_ROWS_EVENT&lt;/code&gt;/ &lt;code&gt;WRITE_ROWS_EVENT&lt;/code&gt;：这三种统称为ROWS_EVENT，分别对应&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;操作，记录在Row模式下所有的DML语句。&lt;code&gt;INSERT&lt;/code&gt;包括需要插入的所有数据；&lt;code&gt;UPDATE&lt;/code&gt;包括修改前的值和修改后的值；&lt;code&gt;DELETE&lt;/code&gt;操作包含被删除的主键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;举个例子&lt;/h2&gt;
&lt;p&gt;当前MySQL版本&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;mysql&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Ver&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;.&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Distrib&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;.&lt;span class="mi"&gt;7&lt;/span&gt;.&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;38&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;debian&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;gnu&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x86_64&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;.&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nv"&gt;Percona&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Server&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;GPL&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Release&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;38&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Revision&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;3692a61&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;设置binlog&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 查看 / 变更设置 - binlog&lt;/span&gt;
vi&lt;span class="w"&gt; &lt;/span&gt;/etc/mysql/percona-server.conf.d/mysqld.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在mysql shell内查看binlog相关事件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;-- 查看mysql版本&lt;/span&gt;
&lt;span class="k"&gt;show&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;variables&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;like&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%version%&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- 查看当前MySQL服务的binlog相关状态&lt;/span&gt;
&lt;span class="k"&gt;show&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;variables&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;like&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%binlog%&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- 查看当前所有的binlog文件列表&lt;/span&gt;
&lt;span class="k"&gt;show&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;binary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;logs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- 查看当前所有的binlog；&lt;/span&gt;
&lt;span class="k"&gt;show&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;binlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- 查看当前binlog with paging&lt;/span&gt;
&lt;span class="k"&gt;show&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;binlog&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mysql-bin.000002&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;624&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- flush当前binlog文件，rotate到下一个binlog文件&lt;/span&gt;
&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;logs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用mysqlbinlog工具查看binlog&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 进入mysql目录需要有su权限&lt;/span&gt;
sudo&lt;span class="w"&gt; &lt;/span&gt;su
&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;/var/log/mysql
&lt;span class="c1"&gt;# 查看binlog索引文件&lt;/span&gt;
cat&lt;span class="w"&gt; &lt;/span&gt;bin-mysql.index
&lt;span class="c1"&gt;# 查看binlog日志文件 - statement&lt;/span&gt;
mysqlbinlog&lt;span class="w"&gt; &lt;/span&gt;--no-defaults&lt;span class="w"&gt; &lt;/span&gt;bin-mysql.000001
&lt;span class="c1"&gt;# 查看binlog日志文件 - row&lt;/span&gt;
mysqlbinlog&lt;span class="w"&gt; &lt;/span&gt;--no-defaults&lt;span class="w"&gt; &lt;/span&gt;--base64-output&lt;span class="o"&gt;=&lt;/span&gt;DECODE-ROWS&lt;span class="w"&gt; &lt;/span&gt;-v&lt;span class="w"&gt; &lt;/span&gt;bin-mysql.000002
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;应用场景&lt;/h2&gt;
&lt;p&gt;前面讲了，Binlog的核心卖点就是能让发生在一个MySQL实例上的所有数据更新能够完整的在其他MySQL实例上重放。MySQL 5.0引入Binlog以支持主从复制，以实现灾难恢复、水平扩展、统计分析、远程数据分发等功能。&lt;/p&gt;
&lt;figure align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/6/binlog-rwsep.png" /&gt;
  &lt;figcaption&gt;基于Binlog主从复制实现的读写分离&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;MySQL进群的主从复制主要有三步，如上图&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Master在每次完成提交事务返回之前，记录本次数据变更事件至Binlog&lt;/li&gt;
&lt;li&gt;Slave基于自身维护的binlog offset，从Master拉取相应的binlog更新。并记录到relay log中。&lt;/li&gt;
&lt;li&gt;Slave消费relay log去更新自身的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面简述几种实际工作中会应用到的场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读写分离：在读多写少的情况下，可使用一个主库接收写流量，准实时地将Binlog同步到多个从库上进行数据同步，以实现读的水平扩展。业务也可以根据需要选择读主库。读多写少的场景在业务toC的业务上非常常见，比如在用户系统中，低频的用户注册 vs. 高频的用户登录行为。&lt;/li&gt;
&lt;li&gt;数据恢复：需要进行数据恢复的时候，将Binlog进行重放即可恢复数据库的状态。&lt;/li&gt;
&lt;li&gt;最终一致性：当需要保证MySQL数据库与其他组件/系统中数据一致时，可以通过订阅Binlog消息的方式进行处理，以避免出现不一致的情况。前司的数据迁移组建先同步存量数据，之后再通过binlog数据处理增量改动。&lt;/li&gt;
&lt;li&gt;异地多活 / 跨DC同步：在异地多活的场景下，存在多主写入，需要互相同步的场景下，需要依赖Binlog进行同步。主要的挑战有数据冲突（主键 / 唯一键）和数据回环问题。前司在亚太区和北美区运营运营app的时候就遇到了用户数据同步的问题，开发了一款同步工具专门用于跨DC数据同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;答疑解惑&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;并发更新下，Binlog的有序性如何保证？&lt;/p&gt;
&lt;p&gt;在老的版本中，通过&lt;code&gt;prepare_commit_mutex&lt;/code&gt;锁以串行的方式来保证MySQL数据库上层Binlog和Innodb存储引擎层的事务提交顺序一致。
MySQL 5.6引入了&lt;code&gt;BLGC（Binary Log Group Commit）&lt;/code&gt;引入队列机制保证Innodb commit顺序与binlog落盘顺序一致，并将事务分组，组内的binlog刷盘动作交给一个事务进行，以保证顺序性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flush Stage: 将每个事务的二进制日志写入内存中。&lt;/li&gt;
&lt;li&gt;Sync Stage: 将内存中的二进制日志刷新到磁盘，若队列中有多个事务，那么仅一次fsync操作就完成了二进制日志的写入，这就是BLGC。&lt;/li&gt;
&lt;li&gt;Commit Stage: 顺序调用存储引擎层事务的提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写Binlog磁盘坏了咋办（单机故障）？&lt;/p&gt;
&lt;p&gt;对于业务（mysql server - 机器硬件）来说，无需额外关心这种细节，默认当成是可靠的就行了。一些额外的细节都可以在磁盘层面做屏蔽，如raid。对于数据来说，定期扫描巡检可以预防数据损坏带来的损失。&lt;/p&gt;
&lt;p&gt;以下原因是导致mysql 表毁坏的常见原因： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器突然断电导致数据文件损坏。 &lt;/li&gt;
&lt;li&gt;强制关机，没有先关闭mysql 服务。 &lt;/li&gt;
&lt;li&gt;mysqld 进程在写表时被杀掉。 &lt;/li&gt;
&lt;li&gt;使用myisamchk 的同时，mysqld 也在操作表。 &lt;/li&gt;
&lt;li&gt;磁盘故障。 &lt;/li&gt;
&lt;li&gt;服务器死机。 &lt;/li&gt;
&lt;li&gt;mysql 本身的bug 。 &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;p&gt;如果你想变得更强的话，可以延伸看看&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_replication_binlog_event.html"&gt;Binlog Event, MySQL Source Code Documentation 官方代码注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.oreilly.com/library/view/mysql-high-availability/9781449341107/ch04.html"&gt;C. Bell, M. Kindahl and L. Thalmann, MySQL High Availability: Tools for Building Robust Data Centers 高可用MySQL：构建健壮的数据中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/replication-sbr-rbr.html"&gt;17.2.1.1 Advantages and Disadvantages of Statement-Based and Row-Based Replication, MySQL 8.0 Reference Manual 官方参考手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/binary-log-mixed.html"&gt;5.4.4.3 Mixed Binary Logging Format, MySQL 8.0 Reference Manual 官方参考手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/replication-features-auto-increment.html"&gt;17.5.1.1 Replication and AUTO_INCREMENT, MySQL 8.0 Reference Manual 官方参考手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mysql.taobao.org/monthly/2014/12/05/"&gt;Binlog event有序性 - 阿里云RDS-数据库内核组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cnblogs.com/mao3714/p/8734838.html"&gt;MySQL 中Redo与Binlog顺序一致性问题&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="Middleware"></category><category term="MySQL"></category></entry></feed>