<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mestrace.github.io</title><link href="https://mestrace.github.io/" rel="alternate"></link><link href="https://mestrace.github.io/feeds/all.atom.xml" rel="self"></link><id>https://mestrace.github.io/</id><updated>2023-02-05T00:00:00+08:00</updated><subtitle>Software Developer</subtitle><entry><title>用 Python 进行代码覆盖率检测：coverage.py 和diff-cover 的使用方法</title><link href="https://mestrace.github.io/posts/2023/Feb/05/python-coverage-diff-cover/" rel="alternate"></link><published>2023-02-05T00:00:00+08:00</published><updated>2023-02-05T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2023-02-05:/posts/2023/Feb/05/python-coverage-diff-cover/</id><summary type="html">&lt;p&gt;在重构项目时，我们经常需要确认代码测试的覆盖率。这是为了确保没有任何部分遗漏或者错误，从而使重构变得更安全 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在重构项目时，我们经常需要确认代码测试的覆盖率。这是为了确保没有任何部分遗漏或者错误，从而使重构变得更安全。为了帮助我们实现这一目标，我们可以使用两个 Python 包来帮助我们 &lt;code&gt;coverage.py&lt;/code&gt; 和 &lt;code&gt;diff-cover&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;coverage.py&lt;/code&gt;是一个代码插桩工具，它能够生成测试覆盖率报告。它的官方仓库是https://github.com/nedbat/coveragepy。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;diff-cover&lt;/code&gt;则是一个比对xml格式的coverage文件的工具，它能够将当前的覆盖率与origin/main或指定的commit进行比对。更多信息请参考它的官方仓库：https://github.com/Bachmann1234/diff_cover。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果您的测试运行命令以&lt;code&gt;python&lt;/code&gt;开头，只需要将初始的&lt;code&gt;python&lt;/code&gt;替换为&lt;code&gt;coverage run&lt;/code&gt;即可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If your test runner command starts with “python”, just replace the initial “python” with “coverage run”.&lt;/p&gt;
&lt;p&gt;python something.py becomes coverage run something.py&lt;/p&gt;
&lt;p&gt;python -m amodule becomes coverage run -m amodule&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在运行完覆盖率的脚本之后，你的项目目录中会多出一个.coverage的元数据文件。为了使结果更加直观，我们需要将其进一步解析为更有说服力的形式。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;coverage report --skip-covered --precision 2 --sort Cover&lt;/code&gt; 命令，你可以在命令行窗口中看到每一个文件的覆盖率情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Name&lt;span class="w"&gt;                             &lt;/span&gt;Stmts&lt;span class="w"&gt;   &lt;/span&gt;Miss&lt;span class="w"&gt;   &lt;/span&gt;Cover
-----------------------------------------------------
admin/models.py&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.00%
admin/views.py&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.00%
api/models.py&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.00%
api/views.py&lt;span class="w"&gt;                         &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.00%
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过使用 &lt;code&gt;coverage html&lt;/code&gt; 命令，你还可以在项目目录中生成一个html文档站，以查看更详细的覆盖率信息，以及覆盖了哪些代码行。&lt;/p&gt;
&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/1/coverage_html.jpeg" /&gt;
&lt;/p&gt;

&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/gei_li.png" /&gt;
&lt;/p&gt;

&lt;p&gt;在对一个巨大的代码库进行修改之后，整个项目的覆盖率并不会有明显的改变，同时也很难定位关注点。为了确保我们的代码修改已经被覆盖到，我们需要提升测试用例的覆盖率，如果没有覆盖到的话，我们需要补充测试用例。有人可能说，这很简单，只需要对比目标分支和当前分支的差异，再去看对应行是否已经被测试覆盖了。幸运的是，已经有人为我们开发了一个工具diff-cover（https://pypi.org/project/diff-cover/ ）。使用coverage.py和diff-cover结合，我们可以迅速找到未被覆盖到的代码。&lt;/p&gt;
&lt;p&gt;我们可以通过执行以下命令生成覆盖率报告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;coverage xml -o test.xml&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，我们可以使用diff-cover读取该报告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;diff-cover test.xml --compare-branch origin/master --html-report diff-cover.html&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，compare-branch参数需要指定用于与当前分支进行diff的分支，html-report参数则输出html格式的覆盖率报告。执行命令后，不仅会在命令行中输出类似如下的覆盖率信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;-------------
Diff Coverage
Diff: origin/master...HEAD, staged and unstaged changes
-------------
account/controllers.py (76.5%): Missing lines 246,302,310,316
account/dao.py (90.3%): Missing lines 262,265,277
account/views.py (0.0%): Missing lines 179,187
-------------
Total:   50 lines
Missing: 9 lines
Coverage: 82%
-------------
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还会生成一个包含具体代码覆盖行的html文档&lt;/p&gt;
&lt;p align="center" width="50%" height="50%"&gt;
  &lt;img src="https://mestrace.github.io/images/1/diff_cover_html.jpeg" /&gt;
&lt;/p&gt;

&lt;p align="center"&gt;
  &lt;img src="https://mestrace.github.io/images/gei_li.png" /&gt;
&lt;/p&gt;

&lt;p&gt;在使用 &lt;code&gt;coverage.py&lt;/code&gt; 进行代码测试覆盖率报告时，我们可能会遇到包含不必要文件和行的情况。例如，Django 自动生成的 &lt;code&gt;manage.py&lt;/code&gt; 文件就不需要我们关注。同样地，代码行 &lt;code&gt;raise NotImplementedError&lt;/code&gt; 也没有什么意义。因此，我们需要将它们屏蔽，以提高代码测试覆盖率报告的精度。&lt;/p&gt;
&lt;p&gt;在运行 &lt;code&gt;coverage.py&lt;/code&gt; 时，可以使用 &lt;code&gt;omit=[pattern1,pattern2…]&lt;/code&gt; 选项忽略某些无关的文件，以及使用 &lt;code&gt;exclude_lines = [pattern1, pattern2]&lt;/code&gt; 选项忽略某些无关的行。例如，使用命令 &lt;code&gt;coverage run --omit="tests" --source='.' manage.py test --keepdb&lt;/code&gt; 可以忽略文件名包含 "tests" 的文件。&lt;/p&gt;
&lt;p&gt;不过，每次都要手动输入 &lt;code&gt;omit&lt;/code&gt; 和 &lt;code&gt;exclude-line&lt;/code&gt; 选项非常麻烦，因此我们可以在项目根目录下配置 &lt;code&gt;.coveragerc&lt;/code&gt; 文件，一次性配置所有选项。&lt;code&gt;.coveragerc&lt;/code&gt; 文件使用 toml 格式编写，在运行 &lt;code&gt;coverage run / coverage report / coverage html&lt;/code&gt; 命令时会读取其中的值并作为参数。&lt;/p&gt;
&lt;p&gt;以下是我在 django 项目中使用的 &lt;code&gt;.coveragerc&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[run]&lt;/span&gt;
&lt;span class="na"&gt;source&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;.&lt;/span&gt;
&lt;span class="na"&gt;omit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;./venv/,*tests,apps.py,*manage.py,_init_.py,migrations,asgi,wsgi,*admin.py,*urls.py&lt;/span&gt;

&lt;span class="k"&gt;[report]&lt;/span&gt;
&lt;span class="na"&gt;omit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;./venv/,*tests,apps.py,*manage.py,_init_.py,migrations,asgi,wsgi,*admin.py,*urls.py&lt;/span&gt;
&lt;span class="na"&gt;exclude_lines&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;pragma&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;no cover&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;def _repr_&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if self.debug&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if settings.DEBUG&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;raise AssertionError&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;raise NotImplementedError&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if 0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;if _name_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;= ._main_.:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;class .*\bProtocol\)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="na"&gt;@(abc\.)?abstractmethod&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;coverage.py&lt;/code&gt; 的官方文档 https://coverage.readthedocs.io/en/7.1.0/&lt;/li&gt;
&lt;li&gt;&lt;code&gt;diff-cover&lt;/code&gt; 的官方文档 https://diff-cover.readthedocs.io/en/latest/README.html&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.coveragerc&lt;/code&gt; 文件来自 https://stackoverflow.com/questions/1628996/is-it-possible-exclude-test-directories-from-coverage-py-reports&lt;/li&gt;
&lt;li&gt;&lt;code&gt;coverage.py&lt;/code&gt; 的 Django 插件 https://pypi.org/project/django-coverage-plugin/&lt;/li&gt;
&lt;/ol&gt;</content><category term="Python"></category><category term="Python"></category></entry><entry><title>RocketMQ是什么</title><link href="https://mestrace.github.io/posts/2021/Sep/11/rocket-mq-history/" rel="alternate"></link><published>2021-09-11T00:00:00+08:00</published><updated>2021-09-11T00:00:00+08:00</updated><author><name>Mestrace</name></author><id>tag:mestrace.github.io,2021-09-11:/posts/2021/Sep/11/rocket-mq-history/</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;Apache RocketMQ is a distributed messaging and streaming platform with low latency, high performance and reliability, trillion-level capacity and flexible scalability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RocketMQ 是一个分布式消息中间件，其具有低延迟、高性能和可靠性、万亿级容 …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;Apache RocketMQ is a distributed messaging and streaming platform with low latency, high performance and reliability, trillion-level capacity and flexible scalability.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RocketMQ 是一个分布式消息中间件，其具有低延迟、高性能和可靠性、万亿级容量、灵活的可扩展性特性。&lt;/p&gt;
&lt;p&gt;&lt;img alt="异构数据下的ETL(Extract, Transform and Load) 处理" src="https://mestrace.github.io/images/2/etl_process.png" /&gt;&lt;/p&gt;
&lt;p&gt;Kafka诞生于所谓的“大数据”时代的早期, 本质是LinkedIn为了解决在不同子系统中进行日志流同步的产物. 在设计之初就专注于对于解决ETL(Extract, transform, and load) 场景连续, 大量的消息数据的生产与消费. 作为一个通用场景的MQ系统, Kafka在大数据领域的实时计算以及日志采集领域被大规模使用. 基于Kafka, LinkedIn构建了一个以日志为中心的大规模分布式系统. 每天产生超过600亿条数据. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Kafka在LinkedIn的使用场景" src="https://mestrace.github.io/images/2/linkedin_kafka_usage.png" /&gt;&lt;/p&gt;
&lt;p&gt;无疑, 基于MQ构建的数据驱动的系统给业务上带来了各种各样的便利和简化. 越来越多的开发者基于Kafka来构建各种应用. 随着时间的推移, 大量的使用也暴露了Kafka的在不同场景下的缺陷, 例如缺乏重试机制, 非严格顺序消费, 和不支持分布式事务. 因此, 阿里巴巴中间件团队针对订单, 交易和充值场景下对于MQ的使用进行了优化, 并与Apache基金会一起开源了RocketMQ. RocketMQ在淘宝的各种活动场景经历了大量的考验. 2017年, 阿里巴巴将RocketMQ开源并捐赠给Apache基金会, 由社区进行维护.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Rocket MQ的历史" src="https://mestrace.github.io/images/2/kafka_history.png" /&gt;&lt;/p&gt;
&lt;p&gt;一个有意思的点: RocketMQ项目只维护核心功能，且去除了所有其他运行时依赖，核心功能最简化。每个BU的个性化需求都在RocketMQ项目之上进行深度定制。RocketMQ向其他BU提供的仅仅是Jar包，例如要定制一个Broker，那么只需要依赖rocketmq-broker这个jar包即可，可通过API进行交互，如果定制client，则依赖rocketmq-client这个jar包，对其提供的api进行再封装。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名词&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;生产组 Producer Group&lt;/td&gt;
&lt;td&gt;标识发送同一类消息的Producer，通常发送逻辑一致。发送普通消息的时候，仅标识使用，并无特别用处。 若事务消息，如果某条发送某条消息的producer-A宕机，使得事务消息一直处于PREPARED状态并超时，则broker会回查同一个group的其 他producer，确认这条消息应该commit还是rollback。但开源版本并不支持事务消息。 注: 字节RMQ暂不支持事务.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;消费组 Consumer Group&lt;/td&gt;
&lt;td&gt;标识一类Consumer的集合名称，这类Consumer通常消费一类消息，且消费逻辑一致。同一个Consumer Group下的各个实例将共同消费topic的消息，起到负载均衡的作用。 消费进度以Consumer Group为粒度管理，不同Consumer Group之间消费进度彼此不受影响，即消息A被Consumer Group1消费过，也会再给Consumer Group2消费。 注： RocketMQ要求同一个Consumer Group的消费者必须要拥有相同的注册信息，即必须要监听一样的topic(并且tag也一样)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Topic&lt;/td&gt;
&lt;td&gt;标识一类消息的逻辑名字，消息的逻辑管理单位。无论消息生产还是消费，都需要指定Topic。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tag&lt;/td&gt;
&lt;td&gt;RocketMQ支持给在发送的时候给topic打tag，同一个topic的消息虽然逻辑管理是一样的。但是消费topic1的时候，如果你订阅的时候指定的是tagA，那么tagB的消息将不会投递。 注: PPE泳道不是以这种方式实现的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;逻辑队列 Message Queue&lt;/td&gt;
&lt;td&gt;消息物理管理单位。一个Topic将有若干个Queue。若Topic同时创建在不通的Broker，则不同的broker上都有若干Queue，消息将物理地存储落在不同Broker结点上，具有水平扩展的能力。 无论生产者还是消费者，实际的生产和消费都是针对Queue级别。例如Producer发送消息的时候，会预先选择（默认轮询）好该Topic下面的某一条Queue地发送.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;集群消费&lt;/td&gt;
&lt;td&gt;消费者的一种消费模式。一个Consumer Group中的各个Consumer实例分摊去消费消息，即一条消息只会投递到一个Consumer Group下面的一个实例。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;广播消费&lt;/td&gt;
&lt;td&gt;消费者的一种消费模式。消息将对一个Consumer Group下的各个Consumer实例都投递一遍。即即使这些 Consumer 属于同一个Consumer Group，消息也会被Consumer Group 中的每个Consumer都消费一次。 注: 字节RMQ暂不支持广播消费&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="Middleware"></category><category term="RocketMQ"></category><category term="Kafka"></category></entry></feed>